# 第三章 复合数据类型
本章主讲四种类型：数组、slice、map、结构体，结构体如何编解码为JSON格式，并结合模版生成HTML页面。
数组、结构体都有固定的内存大小，slice、map是动态的数据结构，动态增长。

## 1. 数组
```go
var a [3]int
var b [3]int = [3]int{1, 2, 3}
c := [...]int{1, 2, 4}
```
数组的长度必须是常量表达式，在编译阶段确定。
数组、slice、map和结构体的写法有一致性。
```go
type Currency int
const (
	USD Currency = iota
	EUR
	GBP
	RMB
)
symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
r := [...]int{99:-1}	// 长度100，初值为0，第100为-1
```
两个数组比较，仅所有元素相等，数组才相等。

函数内部接收参数的是一个复制的副本，不是原始变量，所以传递大的数组类型是低效的；且函数内的修改只影响副本，不影响原始变量（其他语言会隐式地把数组转为引用或指针对象传递）。
Go语言支持函数入参传递数组的指针，但较少使用数组做函数参数，一般使用slice替换数组。

## 2. Slice
slice书写为[]T，和数组语法很像，只是没有固定长度。
slice底层确实引用了一个数组对象。
slice三部分：指针、长度、容量。
slice指针指向其首元素地址（不一定是数组的首元素）。
slice长度即其元素的个数，小于等于容量。
slice容量是从开始位置到底层数据的结尾位置。
内置函数len和cap返回slice的长度和容量。
多个slice可以共享同一个数组，甚至该数组的相同部分。
切片操作str[i:j]，其中`0<=i<=j<=len(str)`；i省略默认为0；j省略默认为len(str);都省略则引用整个数组。
对字符串的切片操作和[]byte字节类型切片类似，切片操作具有常量时间复杂度。
Go语言中，函数入参传递数组常用省略i、j的切片。

函数入参slice创建了slice的一个别名，对其修改会影响原始变量。

slice不能用==比较是否元素相同，不过bytes.Equal可以比较字节型slice是否相等（其他类型的需要展开比较）。
slice是间接引用，==也不能用于判断其是否引用相同对象（浅相等测试），这种行为让人困惑？。
slice唯一合法的比较操作是与nil比较，nil值的slice没有底层数组，长度容量都是0。
Go语言中map等数据结构的key制作简单的浅拷贝，保证相等的key对应相同的元素。

slice判空，应该使用len(s) == 0，而不是s == nil。

内置函数make创建指定元素、长度、容量的匿名slice：
```go
make([]T, len)
make([]T, len, cap)
make([]T, cap)[:len]
```

### append函数
内置函数append用于向slice追加元素。
内置函数copy与赋值语句是一致，返回成功复制的元素的个数，等于两个参数中较小的长度。
append函数扩展slice的数组翻倍长度，使添加操作平均耗时是个常数时间。远超两倍呢？
append函数可以追加多个元素，甚至一个slice。

### slice内存技巧
以切片为入参，且返回切片的函数常用于过滤或合并相邻的元素。
slice可以用来模拟栈或队列（append做压入，索引访问栈顶，切片操作弹出栈顶）。
内置copy函数可以用于删除切片中间的元素`copy(slc[i:], slc[i+1]:)`，或`slc[i] = slc[len(slc)-1]`。

## 3. map
哈希表(map)是无序的key/value对的集合，key不重合，指定key，可在常数时间复杂度内检索、更新或删除对应的值。
Go语言中，map是一个哈希表的引用，书写为map[K]V。key和value的类型必须分别一致。key必须支持==比较运算。
惯例：不用浮点数做key。

创建map表达式：map[K]V{}。
内置make(map[K]V)生成一个匿名map。
map字面值{ key1: value1, key2: value2 }。

map使用下标语法访问元素。查找失败，返回value的零值。使用delete内置函数删除元素（delete(map1, key1)）
map中的value不是一个变量，仅是一个右值表达式，禁止对其做取址操作。（被编译器认为非法）？
如果map的value是指针类型，则可以做寻址操作。
如果map的value的类型是struct，则不能通过`map[key].member += 1`修改它，可以使用指针类型的value修改。

map的遍历顺序是随机的，需要显式排序，可以使用sort包的Strings函数对字符串slice排序。
map的零值是nil，大部分操作对map零值都是安全的，但是向nil值map插入元素导致panic异常。

不应使用value的零值判断元素是否存在，map的下标语法作为右值表达式产生两个值，第二个是布尔值，用于揭示元素是否存在。
map之间不能==比较运算，与nil判断是例外。判断map的每个元素是否相同，需要显式循环遍历（value比较不能直接==比较，需要判断是否存在）。
Go语言中map可以实现类似C++的set的数据结构。

处理不可比较的key类型，需要自定义key比较函数。


## 4. 结构体
点操作符可用于指向结构体的指针访问其成员。
函数调用返回的是值，不能作为左值表达式，如果返回的是可取地址的变量（指针），则可以作为左值。
结构体类型不能包含自身，但可以包含自身类型的指针类型。
如果结构体的成员以大写字母开头，则该成员是导出的。

struct{}大小为0，不含信息，一般不使用。

### 结构体面值
Go语言常用成员名对应初始化来初始化结构体。
未导出的成员不能显式/隐式使用。
较大的结构体常使用指针方式传入和返回函数。
内置函数new？

### 结构体比较
如果结构体的每个成员都可以比较，则结构体也可以比较，并可用于map的key。

### 结构体嵌入和匿名成员
Go语言中可以只声明结构体的一个成员的数据类型，而不指定其名字，也即匿名成员。
匿名成员的数据类型必须是命名类型或命名类型指针。称这种类型嵌入了该结构体。
可以直接访问结构体匿名成员的属性，不需完整级联路径。
嵌套的结构体的初始化面值也是嵌套的`T{T0:T0{a:1, b:2}, c:3}`。
Printf函数中%v参数包含的#副词，表示用和Go语言类似的语法打印面值。
未导出的匿名成员导出的成员对于结构体也未导出的。

匿名成员只是点运算简短书写的语法糖。
嵌入一个没有子成员的匿名成员类型，往往是因为需要嵌入其方法集。
嵌入使Go语言有了对象组合成复杂对象的能力，是Go语言面向对象编程的核心。


## 5. JSON
Go语言对JSON、XML、ASN.1、ProtocalBuffers都有支持。
标准库encoding/json、encoding/xml、encoding/asn1，具有相似的API接口。
JSON类型（数字、布尔、字符串）、JSON数组["a0","a1"]、JSON对象{"k0":"v0"}。

Go语言中结构体slice等转为JSON的过程叫做编组（marshaling），可调用json.Marshaling完成，返回一个编码后的字节slice，没有空白缩进。
json.MarshalingIndent函数产生整齐缩进的输出，其后两个参数表示每一行的前缀和每层级的缩进。
编码时，默认使用结构体成员名做JSON对象（反射技术）。
只有导出的成员才被编码，这也是Go语言用大写字母开头导出的原因。

结构体成员Tag是和在编译阶段关联到该成员的元信息字符串，通常是一系列空格分隔的key:"value"键值对序列；用原生字符串面值形式书写（使用反引号包含）。
以json为key的值用于控制encoding/json等包的编解码行为，第一部分用于指定JSON对象的名字，omitempty选项，表示当该成员为空或零值时，不生成JSON对象。

unmarshaling，json/unmarshaling，解码JSON数据。
url.QueryEscape对url特殊字符进行转译操作。


## 6. 文本和HTML模版
text/template和html/template等包提供更复杂的打印格式，提供一个将变量填充到文本或HTML格式的模版的机制。

