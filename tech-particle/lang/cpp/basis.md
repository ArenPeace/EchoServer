# C++ basis
C++ 基础知识

## hiwork
```cpp
#include <iostream>             // 标准库
using namespace std;            // 命名空间
main() {                        // 无参无返回的main函数
    cout << "hi, work" << endl; // 
}
```

## 数据类型
### 文字常量
+ 字符型 单引号或一字节数字 转义序列(\n \001)
+ 整型 数字 U/u后缀的无符号类型 L/l后缀的长整型 不同进制(0开头八进制 0x开头十六进制)
+ 浮点型 f/F后缀 e/E中缀（科学计数法）
+ 字符串 双引号 L前缀（宽字符文字wchar_t，不可把char[]和wchar_t[]拼接）
+ true/false

静态数据区/const常量
### 内置类型
+ 字符型char
+ 整型 int
+ 浮点型 float double
+ unsigned/short/long修饰符
+ bool类型
### C字符串 与 C++字符串
+ C风格：字符数组
+ C++：std::string类  
本质是数组，原型是？
+ c_str()
### 指针类型
内存地址/动态内存分配/栈上地址
### 引用类型
```cpp
int &ref = entity;
```
引用即别名，提高函数压栈效率而生？栈顶的函数域可以访问整个栈上的数据
### 枚举类型 enum
### 数组类型
[]操作符
### 模板类型
stl容器/pair类型
### 类类型
class/私有数据成员/公开成员函数/拷贝构造函数

编译器为空类提供缺省的构造函数/析构函数/拷贝构造函数/赋值运算符/取值运算符/取值运算符const
#### 构造函数/析构函数
构造函数调用时机：
普通声明/new运算/new[ ]运算/delete运算/delete[ ]运算/定位new运算符/函数入参等

成员初始化列表（可给常量初始化，常量不能赋值）
#### 拷贝构造函数
如果类T的构造函数的第一个参数是T&/const T&/volatile X&/const volatile X&，且没有其他参数或其他参数都有默认值，则这个函数是T的拷贝构造函数。

拷贝构造函数的隐式调用时机
+ 
+ 函数传值

拷贝构造函数不能由成员模板函数生成？
+ 因为成员模板函数不会阻止编译器生成缺省拷贝构造函数，其他缺省函数同理。
+ 显式地声明即使没有实现，不会生成缺省函数。
+ 拷贝构造函数和赋值函数声明为private后，即可禁止类的拷贝和赋值。

##### 浅拷贝/深拷贝
拷贝构造函数&重载赋值运算符函数

对于带有指向堆上内存的指针成员的类，浅拷贝后析构，会造成悬挂指针，对悬挂指针的析构就会造成异常。

深拷贝代价更大，是否必须使用深拷贝呢？
1. 改成传引用或指针做参数形式，不利于上层书写简洁
2. C++11 右值引用
#### return *this
#### 友元函数/友元类
友元函数不是成员函数
#### 运算符重载
+ 可以是类成员函数（第一个操作符是类对象）也可以是友元函数：`T operator+(const T &t);`
+ 运算符<</>>，只能定义为友元，第一个操作数是ostream &out/istream &in，返回值是ostream&/istream&
#### 转换构造函数vs类型转换函数 
接受一个参数的构造函数都可以用作转换函数（隐式/显式），转换函数只能是成员函数且是public。
```cpp
class T {
public:
    T(T1 a) { data = a; } // 转换构造函数，explict声明后，只能显式转换。
    /* 类型转换函数
        operator T1() const { T1 t1; return t1; }
        没有返回值类型，没有参数，函数体里最后返回转换后的值
        T1可以是内置类型/类类型/typedef定义的别名/其他类型（void除外），
        一般也不用数组/函数指针 
        如果定义多个，相近的类型（如互相可转换的两个类型）可能会引起二义性*/
    operator int() const { int t1; return t1; }
private:
    T1 data;
};

int main() {
    T1 t1;
    T t = t1;
    int ival = t;
}
```
可以被继承，可以是虚函数。

### const修饰符 与 static修饰符

### typedef关键字

### volatile修饰符
被修饰的变量，编译器有些优化不会做。
### 强制类型转换
`T a = (T)b;`转换

如果必要，类型总是被提升为

static_cast/dynamic_cast/reinterp_cast/const_cast


## 表达式与操作符
+ 算数（+/-/*///%）
+ 关系与逻辑（>/</=/&&/||/!）
+ 赋值=
+ 递增递减
+ 条件（a?b:c）
+ sizeof
+ new&delete
+ ,(多个语句从左到右计算)
+ 位操作符（~/<</>>/&/|）
+ bitset操作

隐式转换/算术转换/显式转换/强制转换

### new&delete
动态分配对象/对象数组/常量对象

### 定位new运算符
用于硬件编程和基础库编程的内存池内分配，不用析构

#### 动态内存分配

## 流程控制
声明语句/if-else/switch-case-default/for/while/do-while/break/continue/goto

## 函数
+ 引用参数/指针参数&数组参数/缺省参数/缺省号/const参数
+ 函数递归
+ inline
+ extern "C"
+ main()
+ 函数指针
+ 函数重载  
函数名相同，参数类型不同/操作符重载
+ 函数原型
C/C++声明形式
编译链接形式
+ 模板函数

## 内存模型
### 静态变量
全局变量/extern修饰变量/static变量
### 动态内存分配

## 域设计
局部/函数/类/命名空间（可嵌套）
### 命名空间
作用域解析运算符::
using声明
using编译指令

## 面向对象
+ 派生类继承(public继承)基类的public和protected的数据成员和函数成员，
不继承基类的构造函数/析构函数/赋值运算符？
+ 派生类构造，依次调用基类、派生类的构造函数；派生类析构，依次调用派生类、基类的析构函数（析构函数）；
+ 基类可以隐式类型转换地引用指向派生类对象，不可反向
+ 虚函数&虚函数表  
virtual关键字修饰/动态绑定/多态实现
+ 纯虚函数&接口编程
+ 多继承
+ 虚继承
+ class/struct

纯虚函数声明表明该函数没有实现，是为了定义接口，起规范派生类的作用。声明了纯虚函数的类是抽象类，其没有实现纯虚函数的派生类也是抽象类。抽象类不能实例化，只能使用其指针或引用。纯虚函数/抽象类就是为抽象和接口设计而生。

### 三种继承
public/protected/private，派生类从基类继承的成员的访问权限以基类访问权限与继承种类的最低访问级别为准。

class默认使用private继承，struct默认使用public继承

### 虚继承
为了解决菱形继承中重复存储和二义性的问题，如C++标准库中的iostream类从istream/ostream直接继承，而istream/ostream又都继承了base_ios。
istream/ostream必须采用虚继承，不然导致iostream中有两个base_ios的成员的异常。
虚继承的最终派生类只保留了一份虚基类的成员。
多继承存在二义性风险，须审慎处理。
### 基类虚析构函数
基类virtual修饰虚析构函数是为了实现析构函数的多态，C++的面向对象实现的较丑陋。不同的派生类析构的需求不同，甚至比如，动态分配内存的派生类的析构函数需要释放内存。如果基类是非虚析构函数，当调用delete来析构基类指针指向的派生类对象时，就只会调用基类的析构函数，不会调用派生类的析构函数。对于动态分配内存的派生类就产生了内存泄漏。

### 基类的指针和引用的多态
指向或引用派生类的基类的指针或引用

## 泛型设计
函数模板/类模板/标准库

## 异常设计
throw/try-catch-finally
### 函数的throw规范
### 异常类设计

## 基于对象设计
类定义/友元/静态成员/uion类？/位域？bitset类模板/嵌套类/局部类（函数内部声明）/
构造函数/析构函数/拷贝构造函数/public&protected/private

### 拷贝构造函数
引用参数与实参/形参

## 面向对象设计
继承&派生/多继承/虚函数/纯虚函数/接口编程？
### 虚函数表
### 构造函数/析构函数