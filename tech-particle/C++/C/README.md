# C语言
C语言基础详见《C程序语言设计》

本章仅记录一些常见的问题。

## faq
### 字节对齐
自然对齐：一个变量的内存地址正好是它长度的整数倍。
字节对齐的根本原因是CPU访问内存的线路的效率问题（比如int放在偶数地址只需一次脉冲读取，放在奇数地址需要两次脉冲读取，然后拼接在一起），自然对齐访问最快。
一些系统对对齐要求严格，未对齐会报错。
```c
char ch[8];
char *p = &ch[1];
int i = *(int*)p; /* 运行时报错，segment error，x86上只是效率下降 */
```

**正确对齐**  
+ 1.标准数据类型  
其地址是它长度整数倍，char 1，short 2，int/float 4, double 8，long/指针 4（x86，8 x64）
+ 2.数组  
按基本数据类型对齐，第一个是对齐的，其他也就是对齐的。
+ 3.联合类型 union  
按其成员的最大的数据类型对齐。
+ 4.结构体 struct  (或者C++的类)
    + 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
    + 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；
    + 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
```c
struct stu { 
    char val1;
    int val2;
    char val3[10];
};
/* sizeof(stu) = 20 :
最大的是val3长度为10，stu的首地址必须是10的整数倍，stu整个大小是10的整数倍，20；val3前的val1和val2占用10；val1后填充3个字节，val2的地址是4的倍数，后面填充2个字节；
x86和x64相同*/
struct stu1 {
    char val1;
    int val2;
    char val3;
};
struct stu2 {
    char val1;
    double val2;
    char val3;
};
/* sizeof(stu1) = 12 , sizeof(stu2) = 24
编程中考虑节约空间，可以按长度由小到大生命结构体或类的每个成员，减少填补空间，并显现添加填补部分的提示效果。
 */
```

**__attribute__选项**
```c
struct stu3 {
    char val1;
    int val2;
    char val3[10];
} __attribute__((packed));

#pragma pack(2)
struct stu4 {
    char val1;
    int val2;
    char val3[10];
};
#pragma pack()

// } __attribute__((aligned(1))); 实测 sizeof(stu3) = 20
/* sizeof(stu3) = 15 ， sizeof(stu4) = 16:
__attribute__((packed))使变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。
*/
```

**场景**
处理不同的CPU之间的通信时，或编写硬件驱动程序涉及寄存器的结构时候，都需按1字节对齐，即使看起来就是自然对齐的。
隐患：
读取1字节对齐的数据，并强制类型转换会导致以奇数地址访问偶数长度类型数据。

**对齐赋值问题查找**
+ 编译器大小端设置  
x86上，栈由高地址增长到地址，堆反过来。
大小端指数据的高字节再内存中的位置，与CPU内存架构相关。
大端模式，数据高位放在内存中的低地址，方便人理解、自然，如MIPS
小端模式，数据高位放在内存中的高地址，x86 ARM
+ 查看是否支持非对齐访问
+ 是否设置了对齐，或不应该设置对齐？