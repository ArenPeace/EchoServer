redis 集群命令
./redis-trib.rb add-node --slave 127.0.0.1:8102 127.0.0.1:7005
./redis-trib.rb del-node 127.0.0.1:8102 5188d50a9c4ef99017b97b516241345c002ecd6c
./redis-trib.rb  create –replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
./redis-trib.rb check 127.0.0.1:7000 
搭建
1.redis 2.6 可在v100上编译链接（vs2010提供【平台工具集】v100和v90）；之上的版本如2.8 3.0 3.2 需要在v120（由vs2012 vs2015提供）上编译
2.下载redis2.6 编译链接各模块
3.添加redis.conf
4.cmd调用redis-server.exe redis.conf
5.测试

开发
1.新建vs2010工程
    添加hiredis.lib和hiredis.h、win32fixes.c、win32fixes.h等文件到工程
	    项目属性中运行库改为多线程调试（/MTd）或多线程（/MT）
		2.参照网上示例开发。
		 extern "C"{
		  #include <win32fixes.h>
		  }


扩展阅读：
redis简单封装：http://blog.csdn.net/gdutliuyun827/article/details/44339007
redis3.0下载：https://github.com/MSOpenTech/redis
windows版：https://github.com/MSOpenTech/redis/tree/2.6 
2.6 windows版并行出错：http://www.cnblogs.com/triStoneL/archive/2013/08/23/3277709.html
redis教程：http://www.jb51.net/article/56448.htm

参考来源：
windows环境下通过C++使用redis：http://my.oschina.net/sexgirl/blog/496059


redis支持 string list set zset hash （zset为有序集合）这些集合都支持push/pop/add/remove及取交集、并集和差集等操作且这些操作是原子性的。


Hiredis_API说明，hiredisapi


A)编译安装
make
make install (/usr/local)
	make install PREFIX=$HOME/progs(可以自由指定安装路径)


	B)同步的API接口
	redisContext *redisConnect(const char *ip, int port);
	void *redisCommand(redisContext *c, const char *format, ...);
	void freeReplyObject(void *reply);

	1)建立连接
	redisContext *c = redisConnect("127.0.0.1", 6379);
	if (c != NULL && c->err) {
		        printf("Error: %s\n", c->errstr);
				            // handle error
	}

redisConnect函数用来创建一个叫redisContext的东西，它包含了连接相关的信息
它里面有个err字段，0表示正常，其他表示出错了！通过errstr字段可以知晓错误信息

2)执行命令
reply = redisCommand(context, "SET key value");
reply = redisCommand(context, "SET key %s", value);
reply = redisCommand(context, "SET key %b", value, (size_t) valuelen);
reply = redisCommand(context, "SET key:%s %s", myid, value);
redisCommand的调用格式类似printf函数，上面的第二条调用语句的作用在于
输入二进制格式的value内容，其后必须表明二进制的字节长度!


3)redisCommand函数返回一个东西叫redisReply，我们需要通过判断它的type字段
来知道返回了具体什么样的内容：
REDIS_REPLY_STATUS      表示状态，内容通过str字段查看，字符串长度是len字段
REDIS_REPLY_ERROR       表示出错，查看出错信息，如上的str,len字段
REDIS_REPLY_INTEGER    返回整数，从integer字段获取值
REDIS_REPLY_NIL            没有数据返回
REDIS_REPLY_STRING      返回字符串，查看str,len字段
REDIS_REPLY_ARRAY       返回一个数组，查看elements的值（数组个数），通过
                                      element[index]的方式访问数组元素，每个数组元素是
									                                        一个redisReply对象的指针

																			4)另外有一个类似的函数，批量执行命令：
																			void *redisCommandArgv(redisContext *c, int argc,
																					    const char **argv, const size_t *argvlen);

5)redisReply使用完毕后，需要使用函数freeReplyObject进行释放销毁
void redisFree(redisContext *c)的作用是断开连接，并释放redisContext的内容

6)redisCommand的函数执行流程说明：
a.格式化redis command
b.格式化后的命令内容放入redisContext的输出缓冲区
c.调用redisGetReply函数执行命令，得到结果

7)管道的使用方式：
a.填入需要执行的命令
void redisAppendCommand(redisContext *c, const char *format, ...);
void redisAppendCommandArgv(redisContext *c, int argc,
		    const char **argv, const size_t *argvlen);
b.获取命令的输出结果
int redisGetReply(redisContext *c, void **reply);
c.释放输出结果
void freeReplyObject(void *reply);

例子:
redisReply *reply = NULL;
redisAppendCommand(context,"set key1 value");
redisAppendCommand(context,"get key2");
redisGetReply(context,&reply); // reply for set
freeReplyObject(reply);
redisGetReply(context,&reply); // reply for get
freeReplyObject(reply);

订阅模式：
reply = redisCommand(context,"SUBSCRIBE test");
freeReplyObject(reply);
while(redisGetReply(context,&reply) == REDIS_OK) {
	        // consume message
	        freeReplyObject(reply);
}

8)redisReply返回结果处理：
REDIS_OK                    正常
REDIS_ERR_IO        　　IO读/写出现异常，通过errno查看原因
REDIS_ERR_EOF            服务器关闭了链接，读结束
REDIS_ERR_PROTOCOL  分析redis协议内容出错
EDIS_ERR_OTHER          其他未知的错误
上述错误类型都可以通过redisReply的errstr字段查看简短的描述

C)异步API(异步API的使用方式和同步API差不多，在这儿列出不同的函数吧)
	1.连接redis服务器
	redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
	if (c->err) {
		        printf("Error: %s\n", c->errstr);
				            // handle error
	}

2.设置连接、断开的钩子函数
int redisAsyncSetConnectCallback(redisAsyncContext *ac,
		        redisConnectCallback *fn);
int redisAsyncSetDisconnectCallback(redisAsyncContext *ac,
		    redisDisconnectCallback *fn);

3.插入命令信息
int redisAsyncCommand(
		    redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
			    const char *format, ...);
int redisAsyncCommandArgv(
		    redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
			    int argc, const char **argv, const size_t *argvlen);
获取命令输出和同步API相同


4.关闭连接
void redisAsyncDisconnect(redisAsyncContext *ac);


D)辅助API
下面的API主要用于其他编程语言绑定的术后，可以读取分析数据
redisReader *redisReaderCreate(void);
void redisReaderFree(redisReader *reader);
int redisReaderFeed(redisReader *reader, const char *buf, size_t len);
int redisReaderGetReply(redisReader *reader, void **reply);

