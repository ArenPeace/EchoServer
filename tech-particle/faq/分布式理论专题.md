# 分布式理论专题

## 分布式理论
### CAP理论
+ Consistency 一致性  
分布式集群中，对同一数据的多个备份的访问是一致的
+ Availability 可用性  
任何请求都能得到正确的响应，不完全保证获取的数据为最新
+ Partition tolerance 分区容错性  
分布式集群中，一部分节点故障，整体仍然可用  

实际效果，跨区跨机房的服务通信失败很正常（丢包、延时），如果不能在有限时间内完成通信，则发生异常，分区不可用。所以，分布式设计中一定会考虑分区容错。
CAP三者不可得兼，舍一存二（PC/PA）。
经典关系数据库的事务一致性、读写实时性、多表关联查询等很多特性在Web2.0被选择性抛弃了。

**CAP和NoSQL**  
NoSQL更注重性能和可扩展性，而非事务机制（经典关系数据库支持ACID强事务性）。
NoSQL仅提供行级别的原子性保证，即对同一`key-value`操作两次，是串行处理，保证ACID。

**Base理论**  
1. 基本可用 Basically Available
允许部分不可用，整体或核心可用
2. 软状态 Soft State
允许不同节点间副本间同步延时，不影响整体可用。
3. 最终一致性 Eventually Consistency
所有副本最终一致。

Base的思想是即使做不到强一致性，也要达到最终一致性。
这样，分布式的多个副本可以异步复制，达到高性能和最终一致。
最终一致性需要保障用户感知的一致性，用户的不一致窗口取决于通信延时/系统负载/副本复制个数。

DNS是典型的最终一致性。

*acid为酸，base为碱

### Paxos算法
paxos算法是LaTex开发者计算机科学家 莱斯利 兰伯特 提出的，一种基于消息传递且具有高度容错特性的共识（consensus）算法（共识算法不是为了达到一致性，而是分区高度容错的消息传递机制）。

+ 首先将议员的角色分为 proposers，acceptors，和 learners（允许身兼数职）。
+ proposers 提出提案，提案信息包括提案编号和提议的 value；
+ acceptor 收到提案后可以接受（accept）提案，若提案获得多数派（majority）的 acceptors 的接受，则称该提案被批准（chosen）；
+ learners 只能“学习”被批准的提案。

划分角色后，就可以更精确的定义问题：
+ 决议（value）只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案（proposal）”）；
+ 在一次 Paxos 算法的执行实例中，只批准（chosen）一个 value；
+ learners 只能获得被批准（chosen）的 value。

**quorum机制？**

*zk集群的zab协议基于paxos，但并没有完全实现。
### Raft算法
raft算法是要提供更好理解的共识算法，并提供与paxos相同的容错和性能。

Raft透过选举领袖（leader）的方式实做共识算法。

在Raft集群（Raft cluster）里，服务器可能会是这三种身份其中一个：领袖（leader）、追随者（follower），或是候选人（candidate）。在正常情况下只会有一个领袖，其他都是追随者。而领袖会负责所有外部的请求，如果不是领袖的机器收到时，请求会被导到领袖。

通常领袖会借由固定时间发送消息，也就是“心跳（英语：heartbeat）”，让追随者知道集群的领袖还在运作。而每个追随者都会设计超时机制（timeout），当超过一定时间没有收到心跳（通常是150 ms或300 ms），集群就会进入选举状态。

Raft将问题拆成数个子问题分开解决，让人更容易了解：
+ 领袖选举（Leader Election）
+ 记录复写（Log Replication）
+ 安全性（Safety）

## 分布式管理
### zookeeper

### etcd

## Nosql
### redis集群

## 传统数据库
MPP (Massively Parallel Processing)，即大规模并行处理，将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。

Hadoop在处理非结构化和半结构化数据上具备优势，尤其适合海量数据批处理等应用要求。
Hadoop适合海量数据存储查询、批量数据ETL、非机构化数。

MPP适合替代现有关系数据机构下的大数据处理，具有较高的效率。
MPP适合多维度数据自助分析、数据集市等。

简单查询性能相当；HAWQ在处理复杂语句的性能是Hive的三四倍左右。
Hive只支持基准测试99条语句中的66条，而HAWQ支持全部。

## 容器化
### Dokcer
### k8s

## Service Mesh

## 全链路
### ELK

## 分布式ID生成算法
uuid 128太长，zk性能不满足，snowflake需要多研究
### uuid算法
(略)
### snowflake算法
#### 举例
[39bit毫秒数][4bit业务线id][2bit机房id][7bit机器id][5bit预留][7bit毫秒内序号]  
每台服务器绝对递增，全局看只是趋势递增  
必然按msg-id/order-id/worker-id分库分表，取模运算要求ID生成具有“取模随机性",所以毫秒内序列号放最后，保证ID随机  
跨毫秒时，序号总是归0，序号尾为0的比较多，生成的ID取模不均匀，所以不是每次归零，而是归到0-9的随机数。

#### snowflake算法
[1bit不用][41bit时间戳][10bit机器ID][12bit序列号]  
第一比特保留  
时间戳，41比特，从2016年11月1日零点到现在的毫秒数,可以用到2156年，100多年后才会用完  
机器id，10比特，这个机器id每个业务要唯一，机器id获取的策略后面会详述  
序列号，12比特，每台机器每毫秒最多产生4096个id，超过这个数的话会等到下一毫秒  

## 负载均衡算法
web服务器集群，数据库服务器集群，分布式缓存服务集群等集群之前总有负载均衡服务。
云计算/分布式架构，本质也是把后端服务作为计算和存储资源封装到统一入口对外服务。
广泛使用的负载均衡软件：
LVS（linux virtual server)
nginx
haproxy

+ 轮询法，按顺序轮流分配到后端，均衡，不关系后端的存量连接数和系统负载
+ 随机法，按后端列表随机选取，效果接近轮询
+ 源地址哈希，同一IP客户端，总是映射到同一后端
+ 目标地址哈希？
+ 加权轮询，根据后端机器性能和负载，权重不同
+ 加权随机
+ 最小连接数，向最小连接后端分流


### 一致性哈希算法
使用Hash算法让固定的一部分请求（或者数据，下文混用）落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。（不论是分布式缓存还是分布式RPC服务都会使用到）。

普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效，几乎所有的数据都要移动，这个代价很大。

如何当增加或者删除节点时，大多数记录仍然分配到的原来的节点，现在仍然应该分配到那个节点，将数据迁移的代价降到最低，这就是一致性哈希要做的事情。

**环形hash空间**
把key哈希到一个大小为2^32的环形空间（头尾相连的闭合环形，由0~2^32-1的桶组成）。数据的key和存储的节点都哈希到环上，数据存放到按其key哈希值的顺时针方向找到的第一个节点上。机器的增删只需要移动迁移其顺时针方向上第一个节点上的部分数据即可。因为是把节点的信息（如ip）哈希到环上，可能会有些节点的负载很大（倾斜问题），因此引入虚拟节点，把负载分到负载小的实际节点上。

**memcached**  
memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，具体在计算一致性hash时采用如下步骤：
+ 首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。
+ 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。
+ 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。

**redis slot**  
Redis集群并没有直接使用一致性哈希，而是哈希槽（slot），Redis没有直接使用哈希算法hash()，而是使用了crc16校验算法。槽位其实就是一个个的空间的单位。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布，可能会产生数据倾斜问题。而Redis的槽位空间是自定义分配的，类似于Windows盘分区的概念。这种分区是可以自定义大小，自定义位置的。Redis集群包含了16384个哈希槽，每个Key经过计算后会落在一个具体的槽位上，而槽位具体在哪个机器上是用户自己根据自己机器的情况配置的，机器硬盘小的可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。

**其他分布式哈希算法（DHT）**


## 代理机制
agent/proxy/broker/delegate
主动代理/透传代理/中介代理/委托代理