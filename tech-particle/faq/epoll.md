# epoll
## 历史
select()追溯到4.2BSD  
poll system从Linux 2.1.23开始支持  
epoll API从Linux kernel 2.5.44 glibc 2.3.2开始支持  
### epoll、select、poll的区别
+ 1.select最大并发数限制1024个，可以修改  
可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；  
在linux内核头文件中，有这样的定义：#define __FD_SETSIZE    1024
epoll最大并发连接数没有限制，受系统中资源如内存的限制
+ 2.select效率低，每次线性扫描整个fd_set，集合越大速度越慢  
select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件  
epoll通过内核与用户控件mmap同一块内存实现，省去不必要的内存拷贝
+ 3.内核/用户空间内存拷贝问题  
select需要复制大量的句柄数据结构，产生巨大的开销；
+ 4.select的触发方式是水平触发  
应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。  
epoll只有活跃的socket才会主动调用callback，效率提升。

相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。  
并发量低的情况，socket都比较活跃，select不一定比epoll慢；  
高并发时，任意时间，只有少数socket是活跃的，epoll效率更高  
### epoll机制简介
epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？红黑树和双向链表)，把原先的select/poll调用分成了3个部分：
+ 调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)
+ 调用epoll_ctl向epoll对象中添加这100万个连接的套接字
+ 调用epoll_wait收集发生的事件的连接

### 大部分场景
有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的。

## 流的概念

## 多路复用
多路复用本身是数据通信里或者互联网里的概念，指同一信道里同时传输多路信号，有时分多址、码分多址、频分多址等。  
    

## 疑问
epoll的响应处理中，怎么处理io等待？



