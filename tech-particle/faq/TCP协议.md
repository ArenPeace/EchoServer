# TCP

## TCP/UDP
TCP是一种面向连接的通讯，使用的是虚电路（与电话通信不同），而UDP是非连接通讯。前者需要建立连接，保持连接，能够处理断开连接，还要。
### 什么是连接，短链接、长连接的区别和优缺点?
+ 面向连接通讯 Connection-oriented communication  
电话通讯和网络通讯中，一种网络通讯模式，在主体数据被传输前，先建立一个通讯会话或者半永久连接，一个流式数据按序发送传输。

+ 非连接通讯connectionless communication  
ip和udp的数据报模式通讯，数据不按序传输，不同的包独立路由，可通过不同的路径。

    + 1.前者网络负责有序发送报文分组并以一种可靠的方式检测丢失和冲突，经常但不完全是可靠的。后者网络只需将报文分组发送到接受点，检错和流控由发送方和接受方处理。

    + 2.前者在两端之间建立了一条数据通信信道，两端保持联系以协调会话和报文分组的接收或失败的信号。这个信道称为虚电路virtual circuit，与物理网络相对。
    
    在有多条到达目的地路径的网络中，物理路径在会话期间会随着数据模式的改变而改变，但是端点和中间节点一直保持对路径的跟踪。虚电路需要一个建立过程，一旦建立，就为长时间的通讯提供一条有效的路径，如大文件传送。后者的设计用于突发的、暂时的通信，用虚电路建立不是很有效。

    + 3.在分组交换远程通信网络中，有些信道永不断连。两点间建立的一条永久信道称为永久虚电路Permanent virtual circuits PVCs，类似电话专线。

    + 4.无连接模式中，接收方必须检测错误并请求重发；如果分组没有按序到达，需要重新排序。
    
    如TCP/ip协议的ip部分。每个数据分组是网络传输的独立单元，称为数据报。两端没有初始协商，发送方仅仅向网络上发送包含源地址和目标地址的数据报。接收方没有分组接收或未接收的应答，也没有流控制，需要对分组重新排序，如果接收到错误的分组则删掉，重新排序时，发现被删掉的包则请求重发。

    + 5.面向连接需要更多的处理来建立和保持连接，但是没有证实有额外开销。

### TCP短链接  
C/S之间一次请求应答操作，一般都是服务器应答后，客户端来断开连接。  
管理起来简单，存在都是有用的连接，不需要额外的控制手段。
### TCP长连接
TCP keepalive功能  
```
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
// 开启keepalive
s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
// 设置每20秒发送一次心跳包
s.setsockopt(socket.SOL_TCP, socket.TCP_KEEPIDLE, 20)
// 对方没有回应心跳包后，每隔一秒发送一次心跳包
s.setsockopt(socket.SOL_TCP, socket.TCP_KEEPINTVL, 1)
s.connect(('127.0.0.1', 9999)) 
```
保活功能主要为服务器应用提供  
服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。  
在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

## TCP建立连接
## TCP断开连接

## TCP通信怎么控制流量
+ 流量控制  
如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。
     流量控制引发的死锁？怎么避免死锁的发生？
+ 拥塞控制
    + 慢开始算法  
    先探测网络，记录拥塞窗口（cwnd，congestion window，标识网络拥塞程度），发送方把发送窗口等于拥塞窗口（实际在拥塞窗口和接收方窗口选小值）。
    + 拥塞避免  
    经过一个RTT（往返时间，或者传输回合），拥塞窗口加倍。拥塞（没按时收到确认），则发送窗口减半。
    + 快重传算法  
    接收方收到失序报文，不等自己发送数据捎带，而是立马发送重复确认。发送方收到后，立马重传。
    + 快恢复算法  
    发送发收到三个重复确认，发送窗口减半，不执行满开始算法，而是拥塞避免。

### 滑动窗口协议
+ 发送方和接收方分别具有当前序列号nt和nr和一个窗口大小wt和wr。  
窗口大小可能会根据网络流量的变化而有所不同。窗口大小必须大于零才能进行任何操作。操作后，序号发生变化。
+ 当发送方具有要发送的数据时，它可以传输序列号在最新的确认na后的wt个数据包  
指定时间内收到其确认，或者重传。
+ 每次接收到一个编号为x的数据包时，接收方检查它是否落入接收窗口  
是则接受，并发送确认（捎带）；否则丢弃，并发送重复确认（立马）
## TCP怎么保证有序
+ 发送方发送数据时，TCP就给每个数据包分配一个序列号  
在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包：   
    + 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区，并为每个已发送的数据包启动一个超时定时器；  
    + 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;  
    + 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
+ 接收主机利用序列号对接收的数据进行确认  
检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理  
接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。