# C++语言专题

## C++的数据结构
+ map     |红黑树      |有序|
+ list    |双向链表    |无序|
+ vector  |数组        |无序    2倍扩容，拷贝|
+ set     |红黑树      |有序|
+ queue   |单向队列    |无序|
+ deque   |双向队列    |无序|
+ c++11 |unordered_map hashmap |无序|

### C++数组是什么？
是C++内置的数据结构，指向一片连续内存。

### stl vector和list的区别
vector和数组类似，拥有一段连续的内存空间，且起始地址不变。  
高效随机存取，查询速度O(1)，插入和删除的操作，时间复杂度为O(n)。  
当内存不够时，会重新申请一块内存空间并拷贝。  
list是双向链表，内存空间是不连续的。  
通过指针访问数据，随机存取没效率O(n)，能高效插入和删除。  

### map的数据结构
vector封装数组，list封装了链表  
C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般的平衡二叉树(有些书籍根据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树)，所以被STL选择作为了关联容器的内部结构。

### C++迭代器失效问题
vector/deque（序列式容器）插入和删除，导致（当前及其后的）迭代器失效（数组结构导致）   
list插入，导致迭代器失效（当前迭代器失效）  
对于关联容器(如map, set,multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。


### 2GB的数据可以存放到一个map结构中么
抛离具体硬件和操作系统，这个问题没啥意义，32位勉强，64位就看具体内存了。  
linux下勉强可以，几乎不能干别的了。

### 排序算法
std库中的vector list dequeue容器上sort函数?

std的sort()在数据量大的时候使用快速排序，效率为O(log n);
分段后的数据量小于某阈值，改成插入排序，此时基本有序，所以复杂度可达O(n)；
在递归过程中，如果递归层次过深，分割有恶化倾向，则侦测出来后，使用堆排序处理，效果维持在O(n * log n);

## 继承与多态
### 为什么继承中析构函数一定要定义为虚函数
如果不是虚函数，就相当于覆盖了，实例的析构只调用子类的析构函数（调用多次？），可能会造成内存泄漏。

### 64位C++指向虚函数表的指针vfptr占8个字节


### 什么是多态
多态，另一个极端：同构，可以代码复用。  
+ 如相同的接口=》继承多态  
+ 相同的函数名=》重载多态
+ 相同的代码实现=》模板多态

继承多态，函数F(基类指针或引用),F的代码也相同，但其参数的成员函数的行为呈现多态，是不同的。
### 什么是封装
### 什么是类型安全

## FAQ
### 1.共输出几个A
```
for (int i = 0; i < 2; i++) {
    fork();
    printf("A");
} 
```
8个，子进程会继承父进程的缓冲区  
如果是printf("A\n");则是6个，因为\n会将缓冲区flush掉。

### 2.atoi的实现
判断指针非空，异常返回0，下同;  
过滤空格;  
检查'-'号;  
判断'0'-'9'的字符，其他字符则停止，返回当前累计;

### 3.c++的单例实现
singleton

private修饰构造函数、拷贝构造函数、赋值函数;  
静态实例，和静态get函数;

### 4.柔性数组
```
char *p = new char[0];
char a[0];
// 都是gcc合法的

sizeof(a) = 0；
sizeof(*p) = 1；
// p[10] a[10]都可以读写，内容是乱码；
// p[10000] a[10000]一访问就段错误；

// char a[0]同char a[]作为struct最后一个成员时，可以实现一种柔性数组flexible array
```
### 内存泄露 
堆上的内存没有及时释放掉，导致程序运行期间不可重用，即泄露。
泄露过多导致内存耗尽，内存分配失败，程序因此崩溃。

### 缓冲区溢出
绝大多数程序都假设所分配的储存空间足够数据储存，当后者过大时，就产生溢出；  
操作系统使用的缓冲区，即堆栈，各操作进程的指令被临时存储在堆栈中，它也会溢出；  
栈溢出是缓冲区溢出的一种；  

### 内存溢出
栈满时，再做进栈造成空间上溢；栈空时，再做出栈造成下溢出；

内存写越界，即是缓冲区溢出;  
内存读越界，如果地址无效，程序报错崩溃；如果地址有效，读到数据随机;

排查方法：
+ 1.BoundChecker,不是很好用
+ 2.类内部变量莫名其妙变化时，查看this指针变化
+ 3.调试，查看变量值
+ 4.二分法注释代码，看错误是否重现
+ 5.反汇编分析？
+ 6.代码复查

### 内存访问越界
访问了申请的内存之外的空间，结果不具确定性，可能没有问题，可能程序报错崩溃。常见的有数组越界、字符串拷贝越界(sprintf/strcpy/memcpy/等)。  
+ 1.可能破坏了堆中的内存分配信息数据，导致glibc分配和释放内存块时，报free() invalid pointer  或者 malloc() memory corruption 或者 double free or corruption 或者 corruption double-linked list
+ 2.破坏了程序内其他对象的内存空间，导致程序执行结果错误，或者引发coredump，如改变了指针数据
+ 3.破坏了空闲的内存块，影响未知

有时，代码错误被激发是偶然的。排查时，首先保证重现错误，根据错误估计发生位置，逐步裁剪代码，缩小排查空间，检查所有内存操作函数、内存越界可能

sprintf snprintf vsprintf vsnprintf

strcpy strncpy strcat 

memcpy memncpy memmove memset bcopy

如有用到自己编写的动态库，保证编译环境和程序的一致



## char[]和char*的区别
```
char *func() {
    char a[] = "hi";
    return a;
}

char *func() {
    char *p = "hi";
    return p;
}
```
“hi”是一个代码区的字符串常量，放在程序的静态数据区，被写保护，不能写;  
前者在g++编译后返回的是nil，后者返回的是地址；  
前者可以通过a[0] = 'a';修改，后者*p = 'a';运行时报段错误;  
编译时，前者return处警告返回一个局部变量，后者在p初始化处警告将一个常量赋给char*。

## C++ 衰退
只有sizeof alignof（返回对齐的字节数） & 这三个操作符与使用初始化数组的字符串字面量外，表达式中的数据都会被自动转换成指向其首元素的指针。  
不可给数组赋值，因为先转换为指针，且这个指针不可作为左值，这是decay（衰退）。  
左值，放在左边是它的行为。本质上意味着在内存中有确切的位置，可以定位。
只可以用数组下标访问数组的元素。

## c++的流 ，为何cout<<NULL后被关闭
cout << NULL;后，标准输出被关闭，后续不能输出。 
NULL默认关闭cout，再怎么打开呢？  