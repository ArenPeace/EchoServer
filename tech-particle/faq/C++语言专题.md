# C++语言专题

## 为什么继承中析构函数一定要定义为虚函数
如果不是虚函数，就相当于覆盖了，实例的析构只调用子类的析构函数（调用多次？），可能会造成内存泄漏。

## C++的几种数据结构及其实现
+ map     |红黑树      |有序|
+ list    |双向链表    |无序|
+ vector  |数组        |无序    2倍扩容，拷贝|
+ set     |红黑树      |有序|
+ queue   |单向队列    |无序|
+ deque   |双向队列    |无序|
+ c++11 |unordered_map hashmap |无序|

## stl vector和list的区别
vector和数组类似，拥有一段连续的内存空间，且起始地址不变。  
高效随机存取，查询速度O(1)，插入和删除的操作，时间复杂度为O(n)。  
当内存不够时，会重新申请一块内存空间并拷贝。  
list是双向链表，内存空间是不连续的。  
通过指针访问数据，随机存取没效率O(n)，能高效插入和删除。  

## 共输出几个A
```
for (int i = 0; i < 2; i++) {
    fork();
    printf("A");
} 
```
8个，子进程会继承父进程的缓冲区  
如果是printf("A\n");则是6个，因为\n会将缓冲区flush掉。

## atoi的实现
判断指针非空，异常返回0，下同;  
过滤空格;  
检查'-'号;  
判断'0'-'9'的字符，其他字符则停止，返回当前累计;

## c++的单例实现
singleton

private修饰构造函数、拷贝构造函数、赋值函数;  
静态实例，和静态get函数;

## 柔性数组
```
char *p = new char[0];
char a[0];
// 都是gcc合法的

sizeof(a) = 0；
sizeof(*p) = 1；
// p[10] a[10]都可以读写，内容是乱码；
// p[10000] a[10000]一访问就段错误；

// char a[0]同char a[]作为struct最后一个成员时，可以实现一种柔性数组flexible array
```
## 内存泄露 
堆上的内存没有及时释放掉，导致程序运行期间不可重用，即泄露。
泄露过多导致内存耗尽，内存分配失败，程序因此崩溃。

## 缓冲区溢出
绝大多数程序都假设所分配的储存空间足够数据储存，当后者过大时，就产生溢出；  
操作系统使用的缓冲区，即堆栈，各操作进程的指令被临时存储在堆栈中，它也会溢出；  
栈溢出是缓冲区溢出的一种；  

### 内存溢出
栈满时，再做进栈造成空间上溢；栈空时，再做出栈造成下溢出；

内存写越界，即是缓冲区溢出;  
内存读越界，如果地址无效，程序报错崩溃；如果地址有效，读到数据随机;

排查方法：
+ 1.BoundChecker,不是很好用
+ 2.类内部变量莫名其妙变化时，查看this指针变化
+ 3.调试，查看变量值
+ 4.二分法注释代码，看错误是否重现
+ 5.反汇编分析？
+ 6.代码复查

## 内存访问越界
访问了申请的内存之外的空间，结果不具确定性，可能没有问题，可能程序报错崩溃。常见的有数组越界、字符串拷贝越界(sprintf/strcpy/memcpy/等)。  
+ 1.可能破坏了堆中的内存分配信息数据，导致glibc分配和释放内存块时，报free() invalid pointer  或者 malloc() memory corruption 或者 double free or corruption 或者 corruption double-linked list
+ 2.破坏了程序内其他对象的内存空间，导致程序执行结果错误，或者引发coredump，如改变了指针数据
+ 3.破坏了空闲的内存块，影响未知

有时，代码错误被激发是偶然的。排查时，首先保证重现错误，根据错误估计发生位置，逐步裁剪代码，缩小排查空间，检查所有内存操作函数、内存越界可能

sprintf snprintf vsprintf vsnprintf

strcpy strncpy strcat 

memcpy memncpy memmove memset bcopy

如有用到自己编写的动态库，保证编译环境和程序的一致


## 2GB的数据可以存放到一个map结构中么
抛离具体硬件和操作系统，这个问题没啥意义，32位勉强，64位就看具体内存了。  
linux下勉强可以，几乎不能干别的了。

## 11.char[]和char*的区别
```
char *func() {
    char a[] = "hi";
    return a;
}

char *func() {
    char *p = "hi";
    return p;
}
```
“hi”是一个代码区的字符串常量，放在程序的静态数据区，被写保护，不能写;  
前者在g++编译后返回的是nil，后者返回的是地址；  
前者可以通过a[0] = 'a';修改，后者*p = 'a';运行时报段错误;  
编译时，前者return处警告返回一个局部变量，后者在p初始化处警告将一个常量赋给char*。

## 数组是什么？
是c++内置的数据结构。

## C++ 衰退
只有sizeof alignof（返回对齐的字节数） & 这三个操作符与使用初始化数组的字符串字面量外，表达式中的数据都会被自动转换成指向其首元素的指针。  
不可给数组赋值，因为先转换为指针，且这个指针不可作为左值，这是decay（衰退）。  
左值，放在左边是它的行为。本质上意味着在内存中有确切的位置，可以定位。
只可以用数组下标访问数组的元素。

## c++的流 ，为何cout<<NULL后被关闭
cout << NULL;后，标准输出被关闭，后续不能输出。 
NULL默认关闭cout，再怎么打开呢？  

## 64位C++指向虚函数表的指针vfptr占8个字节