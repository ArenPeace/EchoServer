# Linux shell

## 类型与数据结构

## 流程控制

## shell script
```sh
## 仅对当前脚本进程起作用，对子进程不起作用
## 1.当命令的返回值为非零状态时，立即退出脚本的执行，而不是继续执行（很多shell默认执行）
## 如果想根据民工执行的返回值，输出log，则不适用此命令，而是通过exit命令来做退出
set -e

$# # 是传给脚本的参数个数
$0 # 是脚本本身的名字
$1 # 是传递给该shell脚本的第一个参数
$2 # 是传递给该shell脚本的第二个参数
$@ # 是传给脚本的所有参数的列表
$* # 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个
$$ # 是脚本运行的当前进程ID号
$? # 是显示最后命令的退出状态，0表示没有错误，其他表示有错误
$@ # 规则的目标所对应的所有文件。表示规则中的目标文件集。在模式规则中，如果有多个目标，那么"$@"就是匹配于目标中模式定义的集合。

# $* 和 $@
#   都表示传递给函数或脚本的所有参数。
#   不被双引号(" “)包含时，都以”$1" “$2"…"$n” 的形式输出所有参数。
#   当它们被双引号(" “)包含时，”$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"@" 会将各个参数分开，以"$1" “$2"…"$n” 的形式输出所有参数。

```
```sh
# return/exit的异同
# shell脚本中函数调用会新建进程来执行（通过管道传递数据），所以exit只是退出当前进程，而不是退出整个脚本的执行。
#!/usr/bin/env bash
export mainpid=$$
trap "exit 1" TERM

function Fun2()
{
	echo "Fun2 " # 此处$$不能获取进程pid
	#kill -s TERM $mainpid
	kill -9 -$mainpid # 杀死整个进程组
	exit 2
	echo "how" >&2
}

function Fun()
{
	res=$(Fun2)
	echo "Fun "$$   # 此处$$不能获取其进程pid
	echo "are" >&2
	exit 1
}

echo "main "$$
#echo "test "getpid
res=$(Fun)
echo "you"

sleep 20

```

