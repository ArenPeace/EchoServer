管道（Pipe）实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。

一、无名管道
半双工（只能读或只能写）
只能在相关的，有共同祖先的进程间使用
一个fork或者execve调用创建的子进程继承父进程的文件描述符

1.打开和关闭管道
int pipe(int filedes[2]);
在你从一个管道中读出或者写入数据，这个管道必须存在。
如果成功建立了管道，则会打开两个文件描述符，并把他们的值保存在一个整数数组中。
第一个文件描述符用于读取数据，第二个文件描述符用于写入数据。
管道的两个文件描述符相当于管道的两端，一端只负责读数据，一端只负责写数据
如果出错返回-1，同时设置errno
关闭一个文件描述符用close()函数
关闭一个管道的所有文件描述符等于关闭这个管道（不能读不能写）
pipe()函数打开管道一般不会失败

2.读写管道
读写管道与读写普通文件方式一样，调用write与read函数即可。
几乎不会在一个进程中打开一个管道仅供进程自己使用，管道是用来交换数据的。
因为一个进程已经能够访问它要通过管道共享的数据，和自己共享数据是没有意义的。
试图对一个管道的某一端同时进行读写操作是一个严重的错误。

二、管道（Pipe）实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。命名管道（NamedPipes）是在管道服务器和一台或多台管道客户机之间进行单向或双向通信的一种命名的管道。一个命名管道的所有实例共享同一个管道名，但是每一个实例均拥有独立的缓存与句柄，并且为客户——服务通信提供有一个分离的管道。实例的使用保证了多个管道客户能够在同一时间使用同一个命名管道。

1.命名管道由mkfifo()函数创建：
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
mkfifo() 中 path 需要指定为文件的绝对路径。
nkfifoat() 当 fd 为 AT_FDCWD时，则路径名以当前目录开始。
mode 创建一个命名管道时的属性。
一旦创建了FIFO，就可以用 open
打开它，一般的文件访问函数（read、write、close等）都可用于FIFO。
当 open 一个FIFO时，非阻塞标志（O_NONBLOCK）会产生以下影响。
1、没有使用O_NONBLOCK：访问要求无法满足要求时进程将阻塞，如试图读取空FIFO时，将导致进程阻塞。
2、使用O_NONBLOCK：访问要求无法满足时不阻塞，立刻出错返回，errno 是 ENXIO

关闭管道只需要将文件描述符关闭即可，可以使用普通的close()函数逐个关闭。
