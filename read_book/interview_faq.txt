20180612
1.linux 磁盘io 命令 
sar -b 1 10 
iostat
2.多路复用
多路复用本身是数据通信里或者互联网里的概念，指同一信道里同时传输多路信号，有时分多址、码分多址、频分多址等
tcp通信里，epoll、select、poll的区别
    1.select最大并发数限制1024个，可以修改
    2.效率低，每次线性扫描整个fd_set，集合越大速度越慢
    3.内核/用户空间内存拷贝问题
    4.最大并发连接数没有限制，禁受系统中资源如内存的限制
    5.效率提升，只有活跃的socket才会主动调用callback
    6.epoll通过内核与用户控件mmap同一块内存实现，省去不必要的内存拷贝
并发量低的情况，socket都比较活跃，select不一定比epoll慢；
高并发时，任意时间，只有少数socket是活跃的，epoll效率更高
3.mysql存储引擎
mysql存储引擎有多种，常见的有MyISAM和InnoDB
    1.InnoDB支持事务、外键，MyISAM不支持
    2.Inn.DB是mysql5.5后默认的
    3.MyISAM适合查询以及插入为主的应用；InnoDB适合频繁修改以及涉及到安全性较高的应用
    4.InnoDB不支持FULLTEXT类型索引，不保存表的行数
    5.自增长字段，InnoDB必须包含只有该字段的索引，但是MyISAM表中可以和其他字段一起建立联合索引
    6.清空整张表时，InnoDB是一行行删除，很慢；MyISAM则是重建表
    7.InnoDB支持行锁，对于like之类的sql还是锁整张表
4.stl vector和list的区别
vector和数组类似，拥有一段连续的内存空间，且起始地址不变
高效随机存取，查询速度O(1)，插入和删除的操作，时间复杂度为O(n)
当内存不够时，会重新申请一块内存空间并拷贝
list是双向链表，内存空间是不连续的
通过指针访问数据，随机存取没效率O(n)，能高效插入和删除
5.https的实现和区别
http协议传输的数据都是未加密的，也就是明文的，非常不安全
网景公司设计SSL SecureSocketLayer协议用于HTTP协议传输数据加密，诞生了https，比较安全
    1.https协议需要用到ca申请证书，免费的少，需要一定费用
    2.https具有安全性的ssl加密了http的超文本明文传输
    3.https使用了完全不同的连接方式，用的端口也不一样，https443，http80
    4.http简单无状态的，https可进行加密传输、身份认证的网络协议
6.shell脚本实现统计文本中各字符串出现频率
shell sort命令，排序
wc 统计字符
awk 逐行处理
可以先导入数据库，然后count(*) group by

20180620
1.C++的几种数据结构及其实现
map     红黑树      有序
list    双向链表    无序
vector  数组        无序    2倍扩容，拷贝
set     红黑树      有序
queue   单向队列    无序
deque   双向队列    无序
不须了解 c++11 unordered_map hashmap 无序

4.B树是什么
balance tree
B树的意思是balance tree平衡树。
红黑树的数据结构

2.什么是连接，短链接、长连接的区别和优缺点
8.TCP通信怎么控制流量？
面向连接通讯 Connection-oriented communication
电话通讯和网络通讯中，一种网络通讯模式，在主体数据被传输前，先建立一个通讯会话或者半永久连接，一个流式数据按序发送传输。
非连接通讯connectionless communication
ip和udp的数据报模式通讯，数据不按序传输，不同的包独立路由，可通过不同的路径。
    1.前者网络负责书序发送报文分组并以一种可靠的方式检测丢失和冲突，经常但不完全是可靠的。后者网络只需将报文分组发送到接受点，检错和流控由发送方和接受方处理。
    2.前者在两端之间建立了一条数据通信信道，两端保持联系以协调会话和报文分组的接收或失败的信号。这个信道称为虚电路virtual circuit，与物理网络相对。在有多条到达目的地路径的网络中，物理路径在会话期间会随着数据模式的改变而改变，但是端点和中间节点一直保持对路径的跟踪。虚电路需要一个建立过程，一旦建立，就为长时间的通讯提供一条有效的路径，如大文件传送。后者的设计用于突发的、暂时的通信，用虚电路建立不是很有效。
    3.在分组交换远程通信网络中，有些信道永不断连。两点间建立的一条永久信道称为永久虚电路Permanent virtual circuits PVCs，类似电话专线。
    4.无连接模式中，接收方必须检测错误并请求重发；如果分组没有按序到达，需要重新排序。如TCP/ip协议的ip部分。每个数据分组是网络传输的独立单元，称为数据报。两端没有初始协商，发送方仅仅向网络上发送包含源地址和目标地址的数据报。接收方没有分组接收或未接收的应答，也没有流控制，需要对分组重新排序，如果接收到错误的分组则删掉，重新排序时，发现被删掉的包则请求重发。
    5.面向连接需要更多的处理来建立和保持连接，但是没有证实有额外开销。

流量控制：缓冲、窗口机制和拥堵避免

长连接和短连接
长连接多用于频繁读写，如数据库连接，需要心跳保活
短连接多用于web网站http服务，用户不会频繁操作，不需要保活
在HTTP/1.0中，默认使用短连接。从HTTP/1.1起，默认使用长连接，在响应头加入这行：Connection:keep-alive。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务中设置。需要服务端/客户端都支持。
HTTP是个无状态的面向连接的协议。什么是有状态的呢？无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。实质上是TCP的长连接和短连接。
保活功能 如果client一直不关闭连接，server早晚有抗不住的时候，这时候server需要采用一些策略，如主动关闭一些长时间没有读写时间复生的连接，以避免一些恶意连接导致server端崩溃。如果条件允许，可以以客户端机器为颗粒度，限制每个客户端的长连接数量，避免某个客户端拖累整个服务。
短连接较为简单，不需额外的控制手段，如客户请求频繁，将在TCP的连接操作上浪费时间和带宽。所以，长短连接本质是client和server采取的策略不同。没有十全十美的选择。
推送技术 反向AJAX，相对的是拉取

3.select和epoll的机制和作用

5.UDP的使用?TCP握手回收的几个函数和连接的状态。

6.查看进程打开了哪些文件
lsof -c mysql
lsof -u username
lsof -p pid
lsof -i // 列出所有网络连接
lsof -i tcp // 列出所有tcp连接
lsof -i :3306 // 列出所有使用端口的信息
lsof -i tcp:80
lsof -a -u test -i // 列出某个用户的所有活跃的网络端口

7.为什么使用zk和kafka
zk和kafka这种就是前面的1，后面可以加0。
但是从0到1是很难的。
9.进程地址空间
    1.进程使用虚拟内存中的地址，操作系统和硬件把它转成物理地址。 虚拟地址通过页表PageTable映射到物理内存
    2.内核空间在所有页表中拥有较高特权级别，因此用户态程序访问它将会导致一个页错误。
    3.内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。
    4.linux进程在虚拟内存中的标准内存段布局包括高地址的内核空间1GB与底地址用户空间3GB。用户空间地址有高到低包括命令行参数和环境变量、栈、堆、未初始化的数据、初始化的数据、正文。正文段，cpu指令部分，可共享的（内存中多个程序共享一个副本），只读的，写导致错误。初始化数据段，即数据段，包含程序中的全局变量。非初始化数据段，bss段，未初始化的全局变量和静态变量。栈，自动变量及函数调用信息。堆，动态存储分配。堆始于非初始化数据段顶和栈底之间，两者间隔很大。在编译时，函数地址及其他地址就已经确定了。readelf命令可以查看二进制文件中函数入口地址。
10.2GB的数据可以存放到一个map结构中么
11.char[]和char*的区别
char *func() { char a[] = "hi"; return a; }
char *func() { char *p = "hi"; return p; }
“hi”是一个代码区的字符串常量，放在程序的静态数据区，被写保护，不能写
前者在g++编译后返回的是nil，后者返回的是地址；
前者可以通过a[0] = 'a';修改，后者*p = 'a';运行时报段错误
编译时，前者return处警告返回一个局部变量，后者在p初始化处警告将一个常量赋给char*。
cout << NULL;后，标准输出被关闭，后续不能输出。
数组是什么？是c++内置的数据结构，
只有sizeof alignof（返回对齐的字节数） &这三个操作符与使用初始化数组的字符串字面量外，表达式中的数据都会被自动转换成指向其首元素的指针
不可赋值给数组，因为先转换为指针，且这个指针不可作为左值，这是decay（衰退）
左值，放在左边是它的行为。本质上意味着在内存中有确切的位置，可以定位。
只可以用数组下标访问数组的元素
12.c++的流 ，为何cout<<NULL后被关闭
13.epoll的响应处理中，怎么处理io等待
14.怎么衡量计算机的负载是高还是低
15.数据库事务的特性，怎么理解隔离性
原子性 
隔离性
16.for (int i = 0; i < 2; i++) { fork(); printf("A"); } 共输出几个A
8个，子进程会继承父进程的缓冲区
如果是printf("A\n");则是6个，因为\n会将缓冲区flush掉。
17.atoi的实现
ltrim rtrim删除头尾的空格
检查'-'号，判断'0'-'9'的字符
累计
18.c++的单例实现
singleton
private修饰构造函数、拷贝构造函数、赋值函数
静态实例，和静态get函数


