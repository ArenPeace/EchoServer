20180612
1.linux 磁盘io 命令 
sar -b 1 10 
iostat
2.多路复用
多路复用本身是数据通信里或者互联网里的概念，指同一信道里同时传输多路信号，有时分多址、码分多址、频分多址等
tcp通信里，epoll、select、poll的区别
    1.select最大并发数限制1024个，可以修改
    2.效率低，每次线性扫描整个fd_set，集合越大速度越慢
    3.内核/用户空间内存拷贝问题
    4.最大并发连接数没有限制，禁受系统中资源如内存的限制
    5.效率提升，只有活跃的socket才会主动调用callback
    6.epoll通过内核与用户控件mmap同一块内存实现，省去不必要的内存拷贝
并发量低的情况，socket都比较活跃，select不一定比epoll慢；
高并发时，任意时间，只有少数socket是活跃的，epoll效率更高
3.mysql存储引擎
mysql存储引擎有多种，常见的有MyISAM和InnoDB
    1.InnoDB支持事务、外键，MyISAM不支持
    2.Inn.DB是mysql5.5后默认的
    3.MyISAM适合查询以及插入为主的应用；InnoDB适合频繁修改以及涉及到安全性较高的应用
    4.InnoDB不支持FULLTEXT类型索引，不保存表的行数
    5.自增长字段，InnoDB必须包含只有该字段的索引，但是MyISAM表中可以和其他字段一起建立联合索引
    6.清空整张表时，InnoDB是一行行删除，很慢；MyISAM则是重建表
    7.InnoDB支持行锁，对于like之类的sql还是锁整张表
4.stl vector和list的区别
vector和数组类似，拥有一段连续的内存空间，且起始地址不变
高效随机存取，查询速度O(1)，插入和删除的操作，时间复杂度为O(n)
当内存不够时，会重新申请一块内存空间并拷贝
list是双向链表，内存空间是不连续的
通过指针访问数据，随机存取没效率O(n)，能高效插入和删除
5.https的实现和区别
http协议传输的数据都是未加密的，也就是明文的，非常不安全
网景公司设计SSL SecureSocketLayer协议用于HTTP协议传输数据加密，诞生了https，比较安全
    1.https协议需要用到ca申请证书，免费的少，需要一定费用
    2.https具有安全性的ssl加密了http的超文本明文传输
    3.https使用了完全不同的连接方式，用的端口也不一样，https443，http80
    4.http简单无状态的，https可进行加密传输、身份认证的网络协议
6.shell脚本实现统计文本中各字符串出现频率
shell sort命令，排序
wc 统计字符
awk 逐行处理
可以先导入数据库，然后count(*) group by

20180620
1.C++的几种数据结构及其实现
map     红黑树      有序
list    双向链表    无序
vector  数组        无序    2倍扩容，拷贝
set     红黑树      有序
queue   单向队列    无序
deque   双向队列    无序
不须了解 c++11 unordered_map hashmap 无序

4.B树是什么
balance tree
B树的意思是balance tree平衡树。
红黑树的数据结构

2.什么是连接，短链接、长连接的区别和优缺点
8.TCP通信怎么控制流量？
面向连接通讯 Connection-oriented communication
电话通讯和网络通讯中，一种网络通讯模式，在主体数据被传输前，先建立一个通讯会话或者半永久连接，一个流式数据按序发送传输。
非连接通讯connectionless communication
ip和udp的数据报模式通讯，数据不按序传输，不同的包独立路由，可通过不同的路径。
    1.前者网络负责书序发送报文分组并以一种可靠的方式检测丢失和冲突，经常但不完全是可靠的。后者网络只需将报文分组发送到接受点，检错和流控由发送方和接受方处理。
    2.前者在两端之间建立了一条数据通信信道，两端保持联系以协调会话和报文分组的接收或失败的信号。这个信道称为虚电路virtual circuit，与物理网络相对。在有多条到达目的地路径的网络中，物理路径在会话期间会随着数据模式的改变而改变，但是端点和中间节点一直保持对路径的跟踪。虚电路需要一个建立过程，一旦建立，就为长时间的通讯提供一条有效的路径，如大文件传送。后者的设计用于突发的、暂时的通信，用虚电路建立不是很有效。
    3.在分组交换远程通信网络中，有些信道永不断连。两点间建立的一条永久信道称为永久虚电路Permanent virtual circuits PVCs，类似电话专线。
    4.无连接模式中，接收方必须检测错误并请求重发；如果分组没有按序到达，需要重新排序。如TCP/ip协议的ip部分。每个数据分组是网络传输的独立单元，称为数据报。两端没有初始协商，发送方仅仅向网络上发送包含源地址和目标地址的数据报。接收方没有分组接收或未接收的应答，也没有流控制，需要对分组重新排序，如果接收到错误的分组则删掉，重新排序时，发现被删掉的包则请求重发。
    5.面向连接需要更多的处理来建立和保持连接，但是没有证实有额外开销。

流量控制：缓冲、窗口机制和拥堵避免

长连接和短连接
长连接多用于频繁读写，如数据库连接，需要心跳保活
短连接多用于web网站http服务，用户不会频繁操作，不需要保活
在HTTP/1.0中，默认使用短连接。从HTTP/1.1起，默认使用长连接，在响应头加入这行：Connection:keep-alive。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务中设置。需要服务端/客户端都支持。
HTTP是个无状态的面向连接的协议。什么是有状态的呢？无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。实质上是TCP的长连接和短连接。
保活功能 如果client一直不关闭连接，server早晚有抗不住的时候，这时候server需要采用一些策略，如主动关闭一些长时间没有读写时间复生的连接，以避免一些恶意连接导致server端崩溃。如果条件允许，可以以客户端机器为颗粒度，限制每个客户端的长连接数量，避免某个客户端拖累整个服务。
短连接较为简单，不需额外的控制手段，如客户请求频繁，将在TCP的连接操作上浪费时间和带宽。所以，长短连接本质是client和server采取的策略不同。没有十全十美的选择。
推送技术 反向AJAX，相对的是拉取

3.select和epoll的机制和作用

5.UDP的使用?TCP握手回收的几个函数和连接的状态。

6.查看进程打开了哪些文件
lsof -c mysql
lsof -u username
lsof -p pid
lsof -i // 列出所有网络连接
lsof -i tcp // 列出所有tcp连接
lsof -i :3306 // 列出所有使用端口的信息
lsof -i tcp:80
lsof -a -u test -i // 列出某个用户的所有活跃的网络端口

7.为什么使用zk和kafka
zk和kafka这种就是前面的1，后面可以加0。
但是从0到1是很难的。
9.进程地址空间
    1.进程使用虚拟内存中的地址，操作系统和硬件把它转成物理地址。 虚拟地址通过页表PageTable映射到物理内存
    2.内核空间在所有页表中拥有较高特权级别，因此用户态程序访问它将会导致一个页错误。
    3.内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。
    4.linux进程在虚拟内存中的标准内存段布局包括高地址的内核空间1GB与底地址用户空间3GB。用户空间地址有高到低包括命令行参数和环境变量、栈、堆、未初始化的数据、初始化的数据、正文。正文段，cpu指令部分，可共享的（内存中多个程序共享一个副本），只读的，写导致错误。初始化数据段，即数据段，包含程序中的全局变量。非初始化数据段，bss段，未初始化的全局变量和静态变量。栈，自动变量及函数调用信息。堆，动态存储分配。堆始于非初始化数据段顶和栈底之间，两者间隔很大。在编译时，函数地址及其他地址就已经确定了。readelf命令可以查看二进制文件中函数入口地址。
    5.32位windows，进程高位2G留给内核，低位2G留给用户，所以进程堆的大小小于2G，进程栈的大小默认是1M，vs的编译属性可以修改程序运行时进程的栈大小，一个线程栈的大小默认为1M，所以一个进程最多开2048个线程，实际最多大概2000个。
    6.linux下，进程高位1G留给内核，低位3G留给用户，所以进程堆的大小小于3G，进程栈的默认大小是10M，可以通过ulimit -s查看并修改默认栈大小。一个线程栈的大小默认为8M，所以最多380个左右线程。（ulimit -a查看linux的最大进程数大概7000多个。）
    7.线程共享的环境包括进程代码段、进程共有数据、进程打开的文件描述符、信号的处理器、进程的当前目录、进程用户ID与进程组ID。线程独立拥有自己的线程ID、寄存器组的指、线程函数栈区、错误返回码、线程信号屏蔽码、线程的优先级。window平台不同线程缺省使用同一个堆，所以用c的malloc分配内存的时候是使用了同步保护的。
    8.x86_64下，虚拟地址只用了48位，C程序里打印的地址只有12位16进制地址，48位对应了256TB的地址空间。64位地址前16位，4位16进制地址，全0是用户地址，全F是内核地址，这样分为两个128TB地址空间。内核空间有很多空洞hole，其中仅64TB才是直接映射物理内存的区域，PAGE——OFFSET为ffff8800 00000000
    9.pmap -x pid报告进程的内存映射关系
    10.malloc/free函数是通过brk，mmap，munmap等实现

10.2GB的数据可以存放到一个map结构中么
抛离具体硬件和操作系统，这个问题没啥意义，32位勉强，64位就看具体内存了。
linux下勉强可以，几乎不能干别的了
11.char[]和char*的区别
char *func() { char a[] = "hi"; return a; }
char *func() { char *p = "hi"; return p; }
“hi”是一个代码区的字符串常量，放在程序的静态数据区，被写保护，不能写
前者在g++编译后返回的是nil，后者返回的是地址；
前者可以通过a[0] = 'a';修改，后者*p = 'a';运行时报段错误
编译时，前者return处警告返回一个局部变量，后者在p初始化处警告将一个常量赋给char*。
cout << NULL;后，标准输出被关闭，后续不能输出。
数组是什么？是c++内置的数据结构，
只有sizeof alignof（返回对齐的字节数） &这三个操作符与使用初始化数组的字符串字面量外，表达式中的数据都会被自动转换成指向其首元素的指针
不可赋值给数组，因为先转换为指针，且这个指针不可作为左值，这是decay（衰退）
左值，放在左边是它的行为。本质上意味着在内存中有确切的位置，可以定位。
只可以用数组下标访问数组的元素
12.c++的流 ，为何cout<<NULL后被关闭
NULL默认关闭cout，再怎么打开呢？
13.epoll的响应处理中，怎么处理io等待？

14.怎么衡量计算机的负载是高还是低
vmstat 输出一条记录，子系统上次重起后到现在的平均值
vmstat -s 显示各种统计计数和内存统计信息
mpstat 实时系统监控，与cpu有关的统计信息，sysstat安装包里的命令
mpstat -P ALL 每个cpu的使用情况都打印出来，按cpu编号
mpstat 2 100 每2秒刷新一次，刷新100次
uptime 打印系统总共已经运行了多长时间和系统的最近1分钟5分钟15分钟平均负载
iostat 查看系统io状态 -c 查看cpu信息-d磁盘信息
sar -u 1 3 统计cpu使用情况，间隔1秒，统计3次

15.数据库事务的特性，怎么理解隔离性
原子性 要么完成，要么全不完成
一致性 实际并发的结果与理论串行结果一致
隔离性 同一时间仅有一个事务处理同一数据，处理这一数据的其他事务串行化处理，失败的事务不影响数据。
持久性 以提交的事务永久地更改数据保存在数据库中，不会回滚。
实现的方式有两种，write ahead logging 和 shadow paging
后者简单开销大，一个事务修改的块都提交到磁盘，很难并发
前者对数据的修改必须记录到日志中，日志被冲刷到永久存储器中。不需要冲刷数据页。出现崩溃的时候，从日志恢复数据库。
SQL标准中的四个隔离级别
Read-uncommited Read-commited Repeatable-read serializable
问题：脏读、非重复读 幻读（查询了未提交插入的表数据）
mysql默认repeatable-read，其他大多read-commited

16.for (int i = 0; i < 2; i++) { fork(); printf("A"); } 共输出几个A
8个，子进程会继承父进程的缓冲区
如果是printf("A\n");则是6个，因为\n会将缓冲区flush掉。
17.atoi的实现
判断指针非空，异常返回0，下同
过滤空格，
检查'-'号
判断'0'-'9'的字符，其他字符则停止，返回当前累计

18.c++的单例实现
singleton
private修饰构造函数、拷贝构造函数、赋值函数
静态实例，和静态get函数

char *p = new char[0];
char a[0];
都是gcc合法的，
sizeof(a) = 0
sizeof(*p) = 1
p[10] a[10]都可以读写，内容是乱码
p[10000] a[10000]一访问就段错误
char a[0]同char a[]作为struct最后一个成员时，可以实现一种柔性数组flexible array

内存泄露 
堆上的内存没有及时释放掉，导致程序运行期间不可重用，即泄露
泄露过多导致内存耗尽，内存分配失败，程序因此崩溃

内存溢出
栈满时，再做进栈造成空间上溢；栈空时，再做出栈造成下溢出
缓冲区溢出
绝大多数程序都假设所分配的储存空间足够数据储存，当后者过大时，就产生溢出
操作系统使用的缓冲区，即堆栈，各操作进程的指令被临时存储在堆栈中，它也会溢出
栈溢出是缓冲区溢出的一种

内存写越界，即是缓冲区溢出
内存读越界，如果地址无效，程序报错崩溃；如果地址有效，读到数据随机
排查方法：
1.BoundChecker,不是很好用
2.类内部变量莫名其妙变化时，查看this指针变化
3.调试，查看变量值
4.二分法注释代码，看错误是否重现
5.反汇编分析？
6.代码复查

内存访问越界
访问了申请的内存之外的空间，结果不具确定性，可能没有问题，可能程序报错崩溃。常见的有数组越界、字符串拷贝越界(sprintf/strcpy/memcpy/等)。
1.可能破坏了堆中的内存分配信息数据，导致glibc分配和释放内存块时，报free() invalid pointer  或者 malloc() memory corruption 或者 double free or corruption 或者 corruption double-linked list
2.破坏了程序内其他对象的内存空间，导致程序执行结果错误，或者引发coredump，如改变了指针数据
3.破坏了空闲的内存块，影响未知
有时，代码错误被激发是偶然的。排查时，首先保证重现错误，根据错误估计发生位置，逐步裁剪代码，缩小排查空间，检查所有内存操作函数、内存越界可能
sprintf snprintf vsprintf vsnprintf
strcpy strncpy strcat 
memcpy memncpy memmove memset bcopy
如有用到自己编写的动态库，保证编译环境和程序的一致

