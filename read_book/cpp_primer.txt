2016-03-22
文字常量literalconstant
输出操作符<<
与用户终端输出相关联的输出目标cout
编译时时间和日期：__TIME____DATE__
编译时行及文件名：__LINE____FILE__
C标准通用预处理器宏assert()#include<cassert>
异常：数组下标越界、打开文件失败、可用动态内存耗尽、网络连接异常
左值又叫位置值，右值又叫被读取的值；映射计算机组成原理的地址寄存器和数据寄存器；前者要求是可寻址的变量，后者可以是文学常量。
如果变量是在全局域内定义的，系统会保证给它提供初始值0。如果变量是在局部域内定义的，或通过new表达式动态分配的，系统不会，这些对象被称为是未初始化的，不是没有值，而是未定义的，没有文学常量。
空(void*)类型指针可以被任何数据指针类型的地址值赋值，函数指针不行。
const修饰符，可以防止magicnumber，有了它就可以将magicnumber使用左值标识，但不用担心被修改。const量声明时就需要初始化，然后不允许修改。还可以作为不被变更的入参。
const int* pi;//可以改变地址寄存器中的值，不可以改变数据寄存器中的值；
int* const pi;//可以改变数据寄存器中的值，不可以改变地址寄存器中的值。
const int* const pi;?
指针暴露了计算机组成原理的寻址特性：地址寄存器及数据寄存器。
编译时检查，预防运行时错误。
引用即别名，同一主体。可以提供函数轻量压栈。引用是Cpp中的别名构造函数；入参是同类型变量。
int &refi = 23;//错误，运行时23存放在代码区，而不是数据区，此处的别名是错误的声明，也是没有意义的。
const int &refcivalue=3;//却是正确的，汉！！！const会生成临时变量，放到数据区。引用不引起内存分配，const会，指针也会。所以等同于const int civalue=3；
int* &refpi=pi;
const int array_size=6;
const int* const &refci = &array_size;
//const int * &refci和int* const &refci都是错的。
对于以指针为成员的类，做对象拷贝的时候，需要特别处理（根据需求）。
二维数组使用文学常量做初始化声明的时候，第三个开始的左括号表示换行。
typedef类型别名；引用是变量别名；namespace=别名。
类型定义中，*比const优先级高，所以const char *pcc为指向constchar的指针，而const(char*) pcc为const的指向char的指针。const char*等同于char const*;
volatile和const都叫做附加修饰符。
类内定义的成员函数，缺省为inline函数；类外定义的成员函数必须显式声明为inline。
显式转换/强制转换：static_case不引起内存分配，仅仅对原值提供新解析。隐式转换：类型可转，丢失精度，编译警告。
二元操作符的潜在缺点：1.左右操作数的计算顺序是未定义的，计算过程必须是与顺序无关的。（由编译器实现。这是在“有效的实现”和“程序员使用的语言存在潜在缺点”之间的一种折衷）2.不能用于三元。
赋值和初始化都使用'='，但却调用的是不同的成员函数。
推荐内联函数放到头文件中；应该把模版类的实现放到头文件中
内联函数需要在预编译的时候进行“替换”操作，如果它定义在别处，而需要使用内联函数的地方都需要包含其定义所在文件。
模版类在预编译的时候需要生成具体的类定义
float单精度浮点类型，4个字节，1位符号位、8位指数、23位尾数（表示1.0到2.0之间的数，这里的1不以数字形式存储），提供大约3.4E-38到3.4E+38之间的范围，2^23=8388608相当于十进制中的7位；
double双精度浮点类型，8个字节，1位符号位、11位指数、52位尾数，提供大约1.7E-308到1.7E+308的数值范围，2^52=2.220E-16相当于十进制中的16位。

//新建缓冲区，然后在缓冲区中自定义分配内存。
char* buf = new char[sizeof(ST_BOOK)*chunk];
ST_BOOK *pstBook = new(buf) ST_BOOK[10];
pstBook[15].id=234134;//编译器不会检查这里的内存越界

引用参数必须被初始化为指向一个对象，一旦初始化了，就不能再指向其他对象；指针可以指向一系列不同的对象，也可以什么都不指向。（所以函数在确定指针的实际指向一个有效的对象之前不能安全地解引用它）。引用的特别在可以有效地实现重载操作符的同时，还能保证用法的直观性。如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必须使用指针参数。数组永远不会按值传递，实际传递的是第一个元素的指针（下标为0的）。数组具有类型和函数的二相性，类函二相性OMG。
void fun(int(&arr)[10]);//编译器会检查入参是否是int[10]
int funa();//拷贝返回值
int& funb();//允许对引用返回值的修改
const int& func();//防止对引用返回值的无意修改

int (*pia2)[1024]=newint//分配一个4X1024个元素的二维数组

C++异常机制中，throw的可以是刚刚实例化的异常类对象，也可以是枚举成员

面向对象三大特征接口与封装继承与多态，
封装即类、公共和私有、接口与复用、类内内聚类外耦合；
继承即

内聚耦合粒度架构
一行代码一段代码一组代码（函数）多组代码（函数）类模块接口层次基类
过程编程思想：函数，单一功能的聚合，函数内内聚，函数间耦合。
对象编程思想：类，关联的数据和函数的聚合，类内内聚，类间耦合。
切面编程思想：模块，功能特征的聚合，模块内内聚，模块间耦合。
接口编程思想：接口，行为特征抽象，
泛型设计思想：泛型编程，特征抽象，特殊化
继承编程思想：继承，特征抽象
结构体数据聚合

其他问题：版本升级、接口变化、异语言代码重用
COM组件对象模型：工程分解为逻辑组件。逻辑组件符合同一二进制规范，实现组件重用。
组件即符合COM规范的DLL和exe等二进制程序。


const volatile mutable static相爱相杀
类中，指向当前对象的指针this，暗示C++编译器把基于对象的特征翻译成了基于过程（把对象调用解析成指向对象本身的指针作为入参的一般函数调用）。

char*和char[]是不同的类型，char[3]和char[4]也是不同的类型，不能直接赋值；但是char[x]可以看作char*的子类，可以自动转换。

枚举enum、结构体struct、联合union、类class
结构体和联合中，都可以定义函数；
不加public、protected、private限定词的情况下，struct中定义的函数为public，class中定义的函数为private
union还可以定义构造函数和析构函数，是对弱类型的支持，class是对强类型的支持。
union不支持继承、不定义虚函数、没指定访问权限时，默认为public
union中的成员类型比class少：
union里成员变量共享内存，静态、引用都不能用。。。。
。。。。

域解析操作操作符[域名]::全局域解析操作符::


为什么类仅有静态成员函数的地址可以赋值给普通函数指针，是因为类的继承机制。基类的虚函数有个虚函数表，运行时动态绑定（错）
