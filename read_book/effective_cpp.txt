20180528
Effective CPlusPlus 供条款五十
从C转向C++
条款一  尽量使用const和inline，而不用#define
也即，尽量使用编译器而不是预编译。
#define的直接替代，带来很多方便，使用不当也带来很多麻烦
1.有时报错让人费解
2.多次声明或定义
3.嵌套入参，导致预料之外的后果。用inline更好些。
类中常量要定义成静态成员，这样就只有一份拷贝。除了在类的声明中声明，还需要在类的实现中定义。等同于类中做enum{}中定义。

20180604
条款二 尽量用<iostream>而不用<stdio.h>
scanf和printf不是类型安全的，且没有扩展性。这两点是C++的基石？
scanf和printf要把控制读写的格式和读写的内容分开，是种比较老的风格。
推荐用cin、cout，一个类的对象要想用>>和<<处理，需要重载操作符友元函数，以流对象和const类对象的引用为参数
这样，就由编译器根据不用变量类型，选择操作符的不同形式，无需指定

条款三 尽量用new和delete 而不用malloc和free
malloc和free不知道构造函数和析构函数，即它们不会去调用被释放的对象的构造函数和析构函数。
可见c++不是基于对象，而是面向对象编程，基于的是操作系统。
malloc和free只会分配和释放指定大小的连续的内存空间
strdup 拷贝字符串，但程序员容易忘记free掉它返回的对象，所以不被推荐使用。
不要混用，成对使用，局部可全部使用malloc和free

条款四 尽量使用c++风格的注释
C风格/**/ c++风格 // 
这样用/**/注释大片代码的时候就不会失效，或意外情况
在宏定义的尾部添加的//注释，会成为宏定义的一部分

内存管理 
正确地得到内存 和 有效地使用内存，也即正确地调用内存分配和内存释放；特定版本的内存分配和释放
虚拟内存的用处，虚拟内存也是有限的
条款五 对应的new和delete要采用相同的形式
new与delete new[]和delete[]
杜绝对数组类型用typedefs，这很容易导致new和delete的错误。

条款六 析构函数里对指针成员调用delete
类中每新增一个指针成员，都要1.在构造函数里对指针初始化为0，或内存地址，
2.删除现有内存，赋值操作符分配给指针新的内存；3.在析构函数里删除指针。
比较反人类的设计。3特别容易被忽略

条款七 预先准备好内存不够的情况
new产生了异常怎么做
assert只是在没有定义NOEBUG（即调试状态）的时候，检查表达式是否非零，如果是零则发出出错信息，并调用abort
发布状态，assert什么也不做
应当在内存分配不能满足时，调用一个指定函数处理，一般称为new_handler函数
在头文件<new>里有函数
typedef void (*new_handler)();
new_handler set_new_handler(new_handler p) throw();
可以这样：
void noMoreMemory()
{
    cerr << "Unable to satisfy request for memory\n";
    abort();
}
这比简单地让系统内核产生错误信息来结束程序要好。
问题：加入cerr导致动态分配内存，会产生什么？死循环？
new_handler不断重复，直至找到足够的内存。
1.可以在程序启动时分配一个大的内存块，第一次调用new_handler时释放
2.第一次调用new_handler时，调用set_new_handler,改变运行
3.第一次调用new_handler时，传空指针给set_new_handler
没有设置new_handlter，new失败会抛出标准的std::bad_alloc类型异常，或其子类，
送到最初内存申请的地方，缺省行为是abort。
实现类的new操作函数，设置new_handler,new后，设置回原new_handler   并发怎么办？给new操作加锁？

条款八 写operator new与delete时要遵循的常规
只有在出错处理函数指针为空的情况，new才会抛出异常
C++标准规定，即使要求分配0字节内存，operator new也要返回一个合法指针
C++标准规定，所有独立的类的大小都是非零值
operator new、delete、new[]和delete[]要考虑到子类往往比当前的类的大小大些。
1.内存分配支持new_handler；2.正确地处理零内存的分配；3.内存释放处理空指针；4.增加继承支持

条款九 避免隐藏标准形式的new
内部声明的变量或函数会隐藏掉外部相同名称的变量
operator new还比价特殊，特殊在名称易被隐蔽

20180607
条款十 如果写了operator new，就要operator_delete
为什么要自己写operator new和operator delete，为了效率。new是内核操作，
如果申请各种大小内存请求，肯定没有直接申请一块内存块
静态成员不需要显式设置为0，其初始值缺省为0

20180608
条款十一 为需要动态内存分配的类声明一个拷贝构造函数和赋值操作符
类的缺省的拷贝和赋值操作符会执行从一个对象到另一个对象的成员的逐个赋值操作，对指针成员就是逐位拷贝。
那么有两个问题，必发生一个，
1.这个指针成员指向的内存永远不会被释放，造成内存泄漏，
2.一个对象析构导致另一个对象的指针成员非法(错的)
2.两个对象会释放两次分配的内存。
3.将拷贝函数和赋值函数声明为private，禁止调用。
解决方法：1.添加拷贝构造函数和赋值操作符。2.使用引用计数机制跟踪。
后者更复杂，要求构造函数和析构函数做更多工作，但在某些情况下大量节省内存并提高速度
new[]和delete[]也要配对

条款十二 尽量使用初始化而不要再构造函数里赋值
构造函数的成员初始化列表 和 构造函数体内赋值 的重大不同
1.const成员、引用成员、const引用成员，只能用前者
 const引用成员，是个类外可以被修改，类内是只读的对象。
2.前者效率更高
基类的成员初始化和构造函数体执行在派生类之前
如果没有在初始化列表中，类的对象在初始化的时候调用成员的缺省构造函数，初始化一次成员，在其构造函数中再赋值一次。
而在初始化列表中的成员，类的对象在初始化的时候，调用成员的拷贝构造函数初始化成员
3.简化了对类的维护
4.当有大量固定类型数据成员时，最好在构造函数体力赋值，易于维护
5.静态成员只在程序运行过程中初始化一次，永远不会在类中初始化

条款十三 初始化列表中成员列出的顺序和它们在类中声明的顺序不同
类成员是按照类里被声明的顺序进行初始化的，而不是成员初始化列表顺序，两者毫无关系
声明顺序是唯一的，初始化列表顺序可以有多个。
析构的顺序和声明的顺序完全相反。
如果程序按照成员初始化列表初始化，就要记录这个顺序，来做析构。这需要额外开销
所以，成员初始化列表的顺序最好书写的和声明顺序一致，减少错误的直觉。、、、、
静态成员不在此列。
基类到派生类被初始化的顺序和他们的继承顺序一致
那么多继承是什么情况呢？

20180611
条款十四 确定基类有虚析构函数
C++语言标准：当通过基类的指针去删除派生类的对象，而基类又没有虚析构函数时，结果将是不可确定的。经常发生的事，就是派生类的析构函数不会被调用。虚函数表里的信息由编译器确定
一个不会成为基类的类不适合用虚函数，虚函数的实现是通过虚函数表指针，使对象的内存体积增大。
抽象类是准备做基类的，基类必须有一个虚析构函数，纯虚函数会产生抽象类。所以，在想要成为抽象类的类里声明一个纯虚析构函数。
必须提供纯虚析构函数的定义，因为析构函数必须要有定义。
inline 内联函数不是作为独立函数存在，没有函数地址。如果声明虚析构函数为inline，可以避免调用它们产生的开销，但编译器还是会产生此函数的拷贝，以存在函数地址。

条款十五 让operator=返回*this的引用
c++很多的设计，是为了让用户自定义类型尽可能地和固定类型的工作方式相似。如重载运算符、类型转换、赋值、拷贝 
string w,x,y,z; w = x = y = z = "Hello";
C& C::operator=(const C&);
标准string类型提供俩赋值运算符：
1.string& operator=(const string& rhs);
2.string& operator=(const char *rhs);
常发生的错误编程：
1.operator=返回void，阻碍了由右向左连续或链式赋值操作
2.operator=返回const对象的引用，防止(w = x) = y;，const返回值做左值，编译不会通过。
但是对于固定类型，比如int，是可以(i1 = i2) = i3的，为了与其兼容，所以最好不要这样
3.将赋值语句右边的对象返回，不会通过编译，赋值函数入参是const的，不能转成非const返回。
如果赋值函数入参是非const，那x = "hello"将编译不过，因为其右值是const类型相当于const string temp("hello").
普通函数有无必要将参数声明为const的呢？

条款16 在operator=中对所有数据成员赋值
类里增加新的数据成员，也要记得更新赋值运算符函数和构造函数。
还有派生类的赋值运算符、构造函数，
注意：派生类不能给基类私有成员赋值，只能在赋值函数中显式调用基类赋值函数
但是如果基类赋值函数是编译器缺省生成的，Base::operator=(rhs);编译会报错，
必须这样：static_cast<Base&>(*this) = rhs;
static_cast<Base>(*this)会创建新的Base对象，对其赋值不会起到效果，所以要使用Base&
这是个略显丑陋的实现。
对于拷贝构造函数，可以在派生类的拷贝构造函数的成员初始化列表里对Base指定初始化值，看起来，Base是派生类的成员一样。

条款十七 在operator=中检查给自己赋值的情况
C a; a = a;这种情况语法完全正确，甚至a = b; b是a的别名。
检查是否是对自己赋值，一为了效率，不用逐个成员赋值，不用调用基类赋值函数
二为了正确性，赋值函数会释放掉对象的资源，再根据新值分配新的资源，自己给自己赋值可能是场灾难，比如string类型的赋值函数中对字符串指针赋值。
object identity问题，面向对象领域的知名问题，是相同地址既是相同，还是相同内容既是相同

类和函数：设计与声明
好的类型有自然的语法、直观的语义和高效的实现
explicit 声明一个构造函数不能用于隐式转换。

20180613
条款十八 争取使类的接口完整并且最小
函数太多，人们包括程序员很难驾驭，就会打击他们学习使用的积极性
函数的混淆，有些函数叫 think(想)ponder(深思)ruminate(沉思)
函数里重复的代码，复用率低，不易维护，难以保持接口的一致性，需要大量文档维护工作
类的头文件太大，编译时间变长。
能用const就应该用const
同名同参数同返回值的函数成员的声明尾部有和没有const修饰是两个函数，可以认为这里const修饰的是*this
operator<< operator>>这样的函数以及关系运算符，经常用非成员的友元函数，而不是成员函数
友元函数在所有的实际应用中都是类的接口的一部分。

条款十九 分清成员函数，非成员函数和友元函数
成员函数和非成员函数最大的区别，是成员函数可以是虚拟的。
隐式转换，可以将通过类型A的没有explicit修饰的构造函数将类型B转换成类型A，但是却不能调用A的函数。
所以很多操作符实现为非成员函数
操作符=、不在此列
能避免使用友元函数就避免使用友元，友元的麻烦比友元的帮助要多

20180614
条款二十 避免public接口出现数据成员
一致性考虑，避免类的使用者出现直接访问和函数访问数据成员同时出现
函数更精确地控制数据访问权，禁止访问、只读访问、读写访问、线程安全
功能分离，函数里可修改数据的访问，而对用户黑盒

条款二一 尽可能使用const
const是语义上的约束，编译时检查，而不是运行时报错
可以修饰全局或命名空间里的常量或者静态对象，和类里的静态和非静态成员
可以指定指针本身为const，也可以指定指针所指数据为const，或两者都为const，或都不
const放在星号前后是有区别的，类型前后没区别
const可以修饰函数的返回值、参数，对于成员函数还可修饰整个函数
不会降低安全性和效率，减少用户出错几率
声明operator*的返回值为const可以防止，对*运算结果赋值
const和非const成员函数可以重载，可以把类对象看作是const参数，比如operator[]的两种实现
修改一个返回值为固定类型的函数的返回值是不合法的，
所以非const返回值函数的返回值类型需要做左值的时候，必须是引用，不能是固定类型
const修饰的成员函数不能对数据成员赋值，这是C++的数据意义的constness
但是实际上，这个成员函数可以修改指针成员所指向的数据。这就是概念上的constness，违反了数据意义的constness
后门mutable，当对非静态数据成员用mutable修饰时，这些成员的数据意义的constness被解除，可以被修改
类型转换const_cast有些编译器下可以支持，要求保证不会修改它的参数所指向的数据

条款二二 尽量使用传引用，而不是传值
C语言都是通过传值来实现的
传引用省却了传值的拷贝构造函数、析构函数、数据大的时候的压栈出栈操作
参数和返回值，都可以使用引用，而不是传值
避免了切割问题(slicing problem),当派生类的对象作为基类对象被传递时,派生类不能给基类私有成员赋值对象的虚函数表没有传进去。
把派生类赋值给基类，虚函数表并没有拷贝
有时不能传递引用，可以使用指针
基本数据类型，如int传值的效率更高

20180615
条款二三 必须返回一个对象时不要试图返回一个引用
尽可能地让事情简单，但不要过于简单；尽可能让程序高效，但不要过于高效
函数返回局部对象的引用或指针，将导致严重错误
基于堆的对象是通过new产生的，可以用返回指针，不能返回引用，若是引用便无法析构了
不能返回函数内的静态变量，这将导致函数结果的对比永远为true
在某些（大部分）编译器的优化下，传值的效率并不低

条款二四 在函数重载和设定参数缺省值间慎重选择
std::numeric_limits<int>::min()

20180619
条款二五 避免对指针和数字类型重载
什么是‘零’，什么是空，什么是NULL
0是一个int，编译器认为的整数常量的语义
NULL的定义 void * const NULL = 0；需要转义，太丑
C++认为long int 0到null指针的转换，与long int 到int的转换，都是恰当的默认的多语义
#define NULL 0L，二义性太强
没有好的方式，
作为重载函数的设计者，归根结底最基本的一条是，只要有可能，就要避免对一个数字和一个指针类型重载

条款二六 当心潜在的二义性
C++认为潜在的二义性不是一种错误
闭环往往就是二义性，所以A is a B，but B is not A
void f(char); void f(int); double d = 6.32; f(d); 二义性，可通过显式static_cast类型转换解决
派生类继承有相同函数名的两个基类，造成多继承的二义性，刻意显式调用基类，来消除，child.Base::func();
不同的第三方库造成的二义性，。。

20180620
条款二七 如果不想使用隐式生成的函数就要显式地禁止它
对标准C++数组来说，赋值是不合法的
标准C++会提供默认赋值函数，避免使用它的方法是把这个函数声明为private
但成员函数和友元函数仍然会调用它，避免的方法是不定义它。编译器会检查
赋值函数和构造函数具有行为上的相似性，当禁止其中一个的时候，也要禁止另外一个

条款二八 划分全局名字空间
两个命名空间的同名成员，使用时需要显式指明其命名空间
struct也能起到命名空间的作用
typedef可以显式去掉空间引用
定义一个函数的引用 string& (&func)() = func;
struct的运算符函数成员，只能通过用函数形式，而不能用运算符的中缀标识

类和函数：实现类 
类和模版的定义以及合适的函数的声明是最大的设计工作。
怎么做到抽象、对象的生命周期、避免滥用inline

条款二九 避免返回内部数据的句柄
const_cast可以剥离const属性
类的返回内部数据的句柄的函数，可以访问其内部数据
类型转换函数：string::operator const char*() const;
C++标准里，标准string类型包含成员函数c_str如上
上文句柄包括指针和引用
临时对象，造成的访问已销毁的对象，
函数返回句柄，易造成句柄像指针一样悬浮，这是要避免的

20180621
条款三十 避免这样的成员函数：其返回值是指向成员的非const指针或引用，但成员的访问级别比这个函数要低
可以返回执行const对象的指针或引用

条款三一 千万不要返回局部对象的引用，也不要返回函数内部的new初始化的指针的引用

20180622
条款三二 尽可能地推迟变量的定义
C语言要求变量要放在模块头部定义，C++中不用这样
条框十二说明了，缺省构造一个对象再赋值给它 要比 用真正的值来初始化这个对象 效率要低很多。
推迟变量定义从而提高程序的效率，增强程序的条理性，减少变量含义注释

20180625
条款三三 明智地使用内联
内联函数的基本思想是将每个函数调用以其代码体来替换
1.会增加代码体的体积，即代码膨胀，继而导致不合理的页面调度行为（系统颠簸）
过多的内联会降低指令高速缓存的命中率，从而使取指令速度降低。
但如果内联函数体很短，编译器为其生成的代码也就很短，内联将带来更小的目标代码和更高的缓存命中率
2.inline指令就像register，只是对编译器的提示，而不是命令，编译器大多忽略内联复杂的函数（包含循环、递归）
3.inline对虚函数毫无作用，前者是编译时作用，后者是运行时作用
4.旧规则里，对于未被内联的函数，编译器把它当做static处理，引用到它的文件里将产生一份函数拷贝，
导致代码体增加，对其调用将导致多个页面错误
5.如每次获取内联函数地址，将导致编译器为其生成一个函数体，且各自生成为静态拷贝
6.编译器有时会生成构造函数和析构函数的外部拷贝，用以方便地构造和析构类的对象数组
构造函数和析构函数有很多缺省代码，不适合做内联
7.内联函数的代码升级，所有使用它的地方都要重新编译；非内联函数只需重新链接就行。
8.内联函数中的静态对象常表现出反直觉行为，所以避免将包含静态对象的的函数声明为内联
9.找出消耗80%运行时间的20%的代码，选择必须内联以提高性能
没必要就不内联。
10.关注警告信息中的内联函数没有被编译器内联

条款三四 将文件间的编译依赖性将至最低
C++在接口和实现的分离上做的并不好
C++的头文件不仅包含接口规范，还有不少实现细节，导致编译连接很慢
当Smalltalk Eiffel和java定义一个对象时，只分配足够容纳这个对象的一个指针的空间
184页这个类代码很重要，这里不赘述了
分离的关键在于，“对类定义的依赖”被“对类声明的依赖”取代了。
1.如果有可能，尽量让头文件不要依赖于别的文件；
如果不可能，就借助类的声明，不要依靠类的定义。
这一思想直接深化后的含义：
    定义某个类型的引用和指针只会设计这个类型的声明。
    定义这类型的对象则需要类型定义的参与
2.将提供类定义的任务从你的函数声明头文件转交给包含函数调用的用户文件，就可以消除对类型定义的依赖，而这种依赖本来是不必要的，是人为造成的
3.不要在头文件中再包含其他头文件，除非缺少了它就不能编译
相反，要一个一个地声明所需要使用的类，让使用这个头文件的用户自己去包含其他的头文件。使代码可编译
看起来不是很方便，但避免了很多痛苦。事实上也很受推崇，并被运用到C++标准库中
头文件<iosfwd>就包含了iostream库中的类型声明，仅仅是类型声明
4.类中仅仅用一个指针来指向某个不确定的实现，这样的类常常被称为句柄类Handler class或信封类Envelope class。
指针所指向的类，分别对应叫主体类Body class和信件类Letter class
Cheshire猫，它愿意时，会使它的身体部分消失，仅仅留下微笑。
主体类和句柄类含有一样的成员函数，它们的接口完全相同。
句柄类用new隐式地调用主体类构造函数
5.另一种选择是使句柄类成为一种特殊类型的抽象基类，成为协议类Protocal class
协议类存在的目的是为派生类确定一个接口，一般没有数据成员，没有构造函数，有一个虚析构函数，还有一套纯虚函数，用于制定接口
同样，仅在类的接口被修改时，协议类的使用者才需要重新编译
协议类的使用者必然要有函数创建新对象，这个函数扮演构造函数，一般是派生类的构造函数
这种函数可以叫 工厂函数factory function，虚构造函数virtual constructor，
与构造函数行为一样，返回一个指针，指向支持协议类接口的动态分配对象。
这个函数和它创建的对象所对应的协议类是紧密联系的，所以声明它为协议类的静态成员
实现协议类有两个通用机制，1.先从协议类继承接口规范，再实现接口中的函数；2.在条款四三中
6.句柄类和协议类的代价是什么？
运行时会多耗点内存，也会多好点时间
前者通过指针，每次访问要多一层；指针本身的内存开销及初始化操作，还有动态初始化
后者每个函数都是虚函数，也是间接访问，也是更多的内存开销
7.句柄类和协议类都是为了抽象出接口，而内联是服务于细节数据的。
8.在开发阶段要尽量用句柄类和实现类来减少“实现”的改变对它的使用者的负面影响。
但如果带来速度和体积的恶化程度远大于类之间的依赖性的减少程度（平衡），那么当程序化成产品时，就用具体类来取代句柄类和协议类
怎么用工具实现将句柄类和协议类替换为具体类呢？是不是java和python等正在做的事情呢？
9.程序重新编译时消耗的时间的减少也是很有价值的？

继承和面向对象设计
C++的继承和模版为何做者相同的事情？
C++中不同的部件其真正含义是什么，使用它们是做了什么
通过理解C++各个部件，提高自己对面向对象设计的认识。不再停留在区分C++语言的不同部件的区分，而在思考这些部件为你的系统做什么
做想做的，理解所做的！
条款四四总结了C++面向对象构造部件间的对应关系和它们的含义，可作为简明参考

条款三五 使公有继承体现"是一个"的含义
Some must watch while some must sleep，人的记忆，记住这些就会忘掉另外一些
C++面向对象中一条重要的规则是，公有继承意味着“是一个”
派生类Derived 基类Base



