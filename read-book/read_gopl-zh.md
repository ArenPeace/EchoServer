# 第一章 入门
## 1.1 hello world
```
go run xxx.go
go build xxx.go
go get gopl.io/ch1/helloworld 从xxx官网下载源代码
```
每个原文件都以一条package声明语句开始，表示该文件属于哪个包;
紧接着一系列导入import的包;
缺少了必要的包或导入了不需要的包，程序都无法编译通过。
import必须紧跟package之后，导入顺序并不重要。
之后是存储在这个文件里的程序语句，
函数func、变量var、常量const、类型type的声明语句。
go语言惯例：在每个包的包声明之前添加注释，注释语句以//开头。

go语言 不需要在语句或者声明的结尾添加分号，除非一行上有多个语句。
编译器主动把特定符号后的换行符转换为分号。
左括号｛必须和func在同一行上，且位于末尾，不能独占一行，
在表达式x+y中，可在+后换行，不能在+号前换行。

go标准库提供100多个包，以支持输入、输出、排序及文本处理。

gofmt把代码格式化为标准格式，养成格式化代码的习惯，避免无意义的争执。
goimports，根据代码需要自动添加或者删除import声明。
godoc,查看Go语言文档

## 1.2 命令行参数
os包，跨平台提供一些与操作系统交互的函数和变量。
os.Args[0],是命令本身的名字。其他元素os.Args[x]则是参数。
切片slice，同python切片，是一个简版动态数组。
Go语言中，i++是语句，不是表达式，j = i++ 与 --i都是非法的。
Go语言只有"for init; cond; post {...}"循环，且左大括号必须和for同行；init和post都省略时，分号可省略；cond也省略相当于无限循环。
Go语言声明了变量必须使用，不然会导致编译错误，可以使用空标识符("_")替代声明。
空标识符用于任何语法需要，但程序逻辑不需要的时候。
隐式地而非显式地处理，可以减少代码改动？

变量声明一般使用短变量声明(s := "")和普通变量声明(var s string)。前者只能用于函数内部，不能用于包变量。
string使用+=做字符串连接，如果涉及的数据量很大，代价很高。一种简单高效的解决方案是用strings.Join(os.Args[1:], " ")。
Println格式化输出

变量在声明时直接初始化（没有显示初始化的，隐式初始化为零值）

## 1.3 查找重复的行
Go语言的map类似Java的HashMap,Python中的dict，Lua中的table，数学界中的映射。
map的迭代顺序不定，是随机的，每次运行都不一样（Go有意做成这样，防止程序依赖特定顺序遍历）。

bufio包用于高效处理输入输出，Scanner是其最有用的特性之一。
fmt.Printf同C语言的printf(转化符(conversion character)：%g,%e - 浮点数; %t - 布尔值; %q - 带双引号的字符串或单引号的字符?; %v - 变量； %T - 变量类型; ),(转义符(escape  sequences))。惯例：Printf、Errorf以f结尾指format，以ln结尾指line。

Go语言的函数和包级别的变量可以以任意顺序声明，单最好遵循一定规范（我推荐先底层后高层）。

Go语言中，map实例本身是一个引用，作为参数传入函数时，被调用函数的任何修改，调用者都“可见”。

实现上，bufio.Scanner/ioutil.ReadFile/ioutil.WriteFile都使用*os.File的Read和Write函数这些低级函数，但bufio、ioutil的高级函数更易用。

## 1.4 GIF动画
imort的包，只需使用最后那层单词表示。
目前常量的声明值，仅限于数字值、字符串、或布尔值。

复合声明表达式：[]pack.Func{a, b, ...}和pack.Construct{t: t0},前者生成切片，后者生成struct结构体。
struct变量的内部变量可以通过“.”来访问读写。

## 1.5 获取URL
Go语言强大的net包用于处理方位互联网，包括网络收发信息、建立连接、编写服务器程序，结合并发特性。
go run fetch.go http://www.baidu.com

## 1.6 并发获取多个URL
goroutine是一种函数的并发执行方式，channel是在goroutine之间用来做参数传递。
go func表是创建一个新的goroutine，并执行func函数，main也运行在一个goroutine。

make(chan string)创建了string类型的channel，chan是Go语言内置类型，类似于管道。
当一个goroutine往channel上做send/receive操作时，这个goroutine会阻塞在调用处，知道另一个goroutine往该channel里写入/接收，之后两个goroutine才会继续执行。可以用作barrier机制。
ch &lt;- expression, 发送；&lt;-ch, 接收。

## 1.7 Web服务
Go语言允许一个简单的语句结果作为循环的变量声明出现在if语句的最前面，这一点有利于错误处理（限制err这个变量的作用域）。
Go语言支持匿名函数。

## 1.8 其他
Go语言的switch语句不需要在每一个case后写break，默认行为是自动退出。
如果需要switch的几个case都执行同一个逻辑，需要显式地写上一个fallthrough语句来覆盖着各种默认行为，但不推荐使用。
switch还可以不带操作对象，默认用true值代替，case后可以跟着表达式（C中仅能是常量），可以直接罗列多种条件。像其他语言中的if else一样。
无tag switch同switch true等价。
switch也可以跟for和if语句一样紧跟一个简短的变量声明、一个自增表达式、赋值语句、或者一个函数调用。

Go语言支持break、continue、goto来改变程序流，慎用跳转语句。

Go语言有select语句，其case必须是一个发送/接收通信操作，select随机选择一个可运行的case。
如果没有case可运行，select会阻塞至case可运行。
select是和channel绑在一起的。

命名类型也即struct类型名称。

Go语言提供了指针（一种直接存储了变量的内存地址的数据类型），可见的内存地址（&操作符获取变量内存地址，*操作符获取指针指向的变量的值），但是Go语言没有指针运算（C语言可以指针加减法，Go语言不可以）

方法和接口：
方法是和命名类型关联的一类函数。Go语言中方法可以被关联到任意一种命名类型。
接口是一种抽象类型，可以让我们以同样的方式处理不同的固有类型，不用关心其具体实现，只关心其提供的方法。

包：Go语言提供了很多好用的包,且有一个标准库packages（<https://golang.org/pkg>和<https://godoc.org>）。

godoc工具可以在本地阅读标准库的文档。
```
go doc package.Func
```
给每个package、func写一个说明函数行为的注释，是好习惯，这些内容可被godoc这样的工具检测到，并可以做检索。
多行注释可以用/* */，文件开头一般都是这种形式。注释中不再嵌入注释，是好习惯。

# 第二章 程序结构
编程语言中，程序是由大大小小的基础组件构成。组件由变量赋值、加减法运算复合，基础类型聚合为数组或结构体等数据结构，if/for/switch等控制语句，函数做代码隔离和复用，源文件和包隔离函数。

## 2.1 命名
大小写区分；名字必须以一个字母或下划线开头，后面可跟字母、数字、下划线。
关键字25个，如if/else，用于特定语法结构。
30个预定义名字，如int/true，用于内建的常量、类型、函数。
预定义名字可以被程序重新定义，而关键字不行，但仍然不推荐这样做。

函数内部定义，仅函数内可访问；函数外部定义，包内都可访问；函数外部定义（包括函数名）大写字母开头名字，是包导出的，可以被包的外部访问；包内部命名总是用小写字母开头。

惯例，作用域越大，生命周期越长，命名越长。

惯例，优先使用驼峰式命名，即多个单词组成命名，优先使用大小写分隔，而非下划线分隔。
缩略词应当避免大小写混合，如Ascii、Html，应该全大写。

## 2.2 声明
Go主要有四种类型的声明语句，var、const、type、func，分别对应变量、常量、类型、函数实体。

Go源文件以.go为文件后缀名。每个源文件由：包声明语句（所属包）、import语句（导入依赖包）、其他（类型、变量、常量、函数等）

## 2.3 变量
一般形式：
var val T = expression

如果以var val T初始化val，则用零值初始化val。

零值初始化机制:
数值变量对应零值是0，布尔型是false，字符串类型对应的是“”空字符串，接口或引用类型（slice、map、chan和函数）对应的零值是nil。复合类型对应的零值是每一项都是零值。

Go语言的一个声明语句可以声明一组变量，即使不同类型。
Go语言的声明可以用类型，或类型推导。

### 简短变量声明
以val := expression声明变量，根据表达式来推导变量。
同事简短声明多个变量应该仅限于局部的可以提高代码可读性的地方使用。

:=是变量声明语句；=是变量赋值操作。
```
i, j := 0, 1
i, j = j, i
```

简短变量声明的左值，应该至少有一个新的变量，否则编译报错。

### 指针
声明一个指针
```
var val *T
val := &val0
p := new(T)
```

指针的零值都是nil。

Go语言中，返回函数中局部变量的地址是安全的。-_-
？？？如此使用？会不会使垃圾回收困难？比如层层返回一个局部指针，甚至长期驻留？

&操作取地址，相当于创建了新的别名。
指针的价值在于，我们可以不用名字，而是别名来访问变量。
Go语言的垃圾回收器需要知道变量的全部别名。

标准库flag包中的关键技术即是指针。
flag包用于处理-x/--x格式命令行参数，使用指针指向命令行标志参数变量做别名，用于程序处理。

new(T)创建一个匿名变量，并初始化为T的零值，返回*T。
new(T)同返回局部变量的地址行为相同。

struct{}和[0]int，类型的大小为0，可能地址相同，依赖于具体编译器，其自动垃圾回收器的行为也不同。

### 变量的声明周期
变量的声明周期从创建开始，直到其不再被引用。

函数的小括号里，可以另起一行缩进，但是要满足以(/,/)结束，不然编译器会在行尾自动插入分号导致编译错误。

Go语言的自动垃圾收集器通过每个变量是否可达，判断其是否可以被回收。
所以，一个循环迭代内部的局部变量的生命周期可能超出其作用域，同时，函数内局部变量可以在返回后依然存在（Go语言中称之为逃逸）。
编译器来选择在栈上还是在堆上分配局部变量的存储空间，且不取决与用var还是new声明变量。
逃逸的变量需要额外分配内存，对性能会产生细微的影响。

把局部短生命周期变量的指针保存到长生命周期的对象中，特别是全局变量时，会阻止对其的来及回收，进而影响性能。

## 2.4 赋值
Go语言支持 += ++等快捷代码，但++是语句，而不是表达式！！！

### 元组赋值：
允许同事更新多个变量的值。赋值前，先对右值求值，再统一赋给左值。很便利，且代码紧凑。

map查找、类型断言、通道接收，都有一个额外的布尔结果值表示操作是否成功。
```
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
```

可赋值性也即右值表达式/左值表达式，仅右值表达式可以放赋值语句右边，可以在==等的右边。

## 2.5 类型
type T basetype

不同的类型，即使它们的底层类型相同也是不兼容的（不能互相赋值、比较、混在一起运算）。
新命名的类型提供了一个方法T(x)(或(T)(x), 当T是指针类型时)，把x转为T类型，当且仅当两个类型的底层基础类型或指针类型相同时，才允许此转型操作。
一个浮点数转整数，会丢小数部分；把字符串转为[]byte类型slice，会拷贝出一个字符串的副本。
转换函数不会运行时失败，只会编译时失败。

命名类型较多地用于复杂struct类型书写简化。
命名类型还可以为其值定义新的行为，即关联到该类型的函数集合。
命名类型的String方法，会被fmt.Print系列优先使用

## 2.6 包和文件
包、文件是为支持模块化、封装、单独编译和代码重用。
一个包所在的目录路径的后缀是包的导入路径（$GOPATH/src后面的部分）。
每个包都对应一个独立的名字空间，不同包的同名变量需要显式使用包名以区分。不同名也不可以省略。
包内大写字母开头的变量是导出的，汉字和日文unicode编码相当于小写字母开头，需要特殊设置。
包级别的名字，在同包的其他源文件中是可以直接访问的，同所有代码在一个文件中。
惯例：包注释的第一句应该先是包的功能概要声明。如果一个包多个包注释，文档工具（go doc）会根据源文件先后顺序链接它们为一个包注释。
惯例：包注释很大，通常会放到一个独立的doc.go文件。

### 包导入
import语句中的字符串对应导入路径，由构建工具解释，默认的工具箱代表一个目录中的一个或多个Go源文件。
源文件中的包名，不要求唯一。
惯例：源文件中的包名，和import语句中的包的导入路径的最后一节目录名相同。
同时导入两个同名包，必须有一个同名包添加别名（原文，重命名）。
导入包，却没有使用，将导致一个编译错误，需要删除或注释掉。
goimports

go env // 查看golang环境变量
GOROOT：golang的安装路径，安装时确定。
GOPATH：golang工作路径；bin - 二进制文件路径; pkg - .a文件存放路径；src - go run、go install等命令路径
GOBIN:go install的存放路径

go get:
+ 1.从远程下载需要用到的包
+ 2.执行go install

go install会生成可执行文件放到bin目录；编译普通包，生成.a文件放到pkg目录。













