# 第一章 入门
## 1.1 hello world
```
go run xxx.go
go build xxx.go
go get gopl.io/ch1/helloworld 从xxx官网下载源代码
```
每个原文件都以一条package声明语句开始，表示该文件属于哪个包;
紧接着一系列导入import的包;
缺少了必要的包或导入了不需要的包，程序都无法编译通过。
import必须紧跟package之后，导入顺序并不重要。
之后是存储在这个文件里的程序语句，
函数func、变量var、常量const、类型type的声明语句。
go语言惯例：在每个包的包声明之前添加注释，注释语句以//开头。

go语言 不需要在语句或者声明的结尾添加分号，除非一行上有多个语句。
编译器主动把特定符号后的换行符转换为分号。
左括号｛必须和func在同一行上，且位于末尾，不能独占一行，
在表达式x+y中，可在+后换行，不能在+号前换行。

go标准库提供100多个包，以支持输入、输出、排序及文本处理。

gofmt把代码格式化为标准格式，养成格式化代码的习惯，避免无意义的争执。
goimports，根据代码需要自动添加或者删除import声明。
godoc,查看Go语言文档

## 1.2 命令行参数
os包，跨平台提供一些与操作系统交互的函数和变量。
os.Args[0],是命令本身的名字。其他元素os.Args[x]则是参数。
切片slice，同python切片，是一个简版动态数组。
Go语言中，i++是语句，不是表达式，j = i++ 与 --i都是非法的。
Go语言只有"for init; cond; post {...}"循环，且左大括号必须和for同行；init和post都省略时，分号可省略；cond也省略相当于无限循环。
Go语言声明了变量必须使用，不然会导致编译错误，可以使用空标识符("_")替代声明。
空标识符用于任何语法需要，但程序逻辑不需要的时候。
隐式地而非显式地处理，可以减少代码改动？

变量声明一般使用短变量声明(s := "")和普通变量声明(var s string)。前者只能用于函数内部，不能用于包变量。
string使用+=做字符串连接，如果涉及的数据量很大，代价很高。一种简单高效的解决方案是用strings.Join(os.Args[1:], " ")。
Println格式化输出

变量在声明时直接初始化（没有显示初始化的，隐式初始化为零值）

## 1.3 查找重复的行
Go语言的map类似Java的HashMap,Python中的dict，Lua中的table，数学界中的映射。
map的迭代顺序不定，是随机的，每次运行都不一样（Go有意做成这样，防止程序依赖特定顺序遍历）。

bufio包用于高效处理输入输出，Scanner是其最有用的特性之一。
fmt.Printf同C语言的printf(转化符(conversion character)：%g,%e - 浮点数; %t - 布尔值; %q - 带双引号的字符串或单引号的字符?; %v - 变量； %T - 变量类型; ),(转义符(escape  sequences))。惯例：Printf、Errorf以f结尾指format，以ln结尾指line。

Go语言的函数和包级别的变量可以以任意顺序声明，单最好遵循一定规范（我推荐先底层后高层）。

Go语言中，map实例本身是一个引用，作为参数传入函数时，被调用函数的任何修改，调用者都“可见”。

实现上，bufio.Scanner/ioutil.ReadFile/ioutil.WriteFile都使用*os.File的Read和Write函数这些低级函数，但bufio、ioutil的高级函数更易用。

## 1.4 GIF动画
imort的包，只需使用最后那层单词表示。
目前常量的声明值，仅限于数字值、字符串、或布尔值。

复合声明表达式：[]pack.Func{a, b, ...}和pack.Construct{t: t0},前者生成切片，后者生成struct结构体。
struct变量的内部变量可以通过“.”来访问读写。

## 1.5 获取URL
Go语言强大的net包用于处理方位互联网，包括网络收发信息、建立连接、编写服务器程序，结合并发特性。
go run fetch.go http://www.baidu.com

## 1.6 并发获取多个URL
goroutine是一种函数的并发执行方式，channel是在goroutine之间用来做参数传递。
go func表是创建一个新的goroutine，并执行func函数，main也运行在一个goroutine。

make(chan string)创建了string类型的channel，chan是Go语言内置类型，类似于管道。
当一个goroutine往channel上做send/receive操作时，这个goroutine会阻塞在调用处，知道另一个goroutine往该channel里写入/接收，之后两个goroutine才会继续执行。可以用作barrier机制。
ch &lt;- expression, 发送；&lt;-ch, 接收。

## 1.7 Web服务
Go语言允许一个简单的语句结果作为循环的变量声明出现在if语句的最前面，这一点有利于错误处理（限制err这个变量的作用域）。
Go语言支持匿名函数。

## 1.8 其他
Go语言的switch语句不需要在每一个case后写break，默认行为是自动退出。
如果需要switch的几个case都执行同一个逻辑，需要显式地写上一个fallthrough语句来覆盖着各种默认行为，但不推荐使用。
switch还可以不带操作对象，默认用true值代替，case后可以跟着表达式（C中仅能是常量），可以直接罗列多种条件。像其他语言中的if else一样。
无tag switch同switch true等价。
switch也可以跟for和if语句一样紧跟一个简短的变量声明、一个自增表达式、赋值语句、或者一个函数调用。

Go语言支持break、continue、goto来改变程序流，慎用跳转语句。

Go语言有select语句，其case必须是一个发送/接收通信操作，select随机选择一个可运行的case。
如果没有case可运行，select会阻塞至case可运行。
select是和channel绑在一起的。

命名类型也即struct类型名称。

Go语言提供了指针（一种直接存储了变量的内存地址的数据类型），可见的内存地址（&操作符获取变量内存地址，*操作符获取指针指向的变量的值），但是Go语言没有指针运算（C语言可以指针加减法，Go语言不可以）

方法和接口：
方法是和命名类型关联的一类函数。Go语言中方法可以被关联到任意一种命名类型。
接口是一种抽象类型，可以让我们以同样的方式处理不同的固有类型，不用关心其具体实现，只关心其提供的方法。

包：Go语言提供了很多好用的包,且有一个标准库packages（<https://golang.org/pkg>和<https://godoc.org>）。

godoc工具可以在本地阅读标准库的文档。
```
go doc package.Func
```
给每个package、func写一个说明函数行为的注释，是好习惯，这些内容可被godoc这样的工具检测到，并可以做检索。
多行注释可以用/* */，文件开头一般都是这种形式。注释中不再嵌入注释，是好习惯。

# 第二章 程序结构
编程语言中，程序是由大大小小的基础组件构成。组件由变量赋值、加减法运算复合，基础类型聚合为数组或结构体等数据结构，if/for/switch等控制语句，函数做代码隔离和复用，源文件和包隔离函数。

## 2.1 命名
大小写区分；名字必须以一个字母或下划线开头，后面可跟字母、数字、下划线。
关键字25个，如if/else，用于特定语法结构。
30个预定义名字，如int/true，用于内建的常量、类型、函数。
预定义名字可以被程序重新定义，而关键字不行，但仍然不推荐这样做。

函数内部定义，仅函数内可访问；函数外部定义，包内都可访问；函数外部定义（包括函数名）大写字母开头名字，是包导出的，可以被包的外部访问；包内部命名总是用小写字母开头。

惯例，作用域越大，生命周期越长，命名越长。

惯例，优先使用驼峰式命名，即多个单词组成命名，优先使用大小写分隔，而非下划线分隔。
缩略词应当避免大小写混合，如Ascii、Html，应该全大写。

## 2.2 声明
Go主要有四种类型的声明语句，var、const、type、func，分别对应变量、常量、类型、函数实体。

Go源文件以.go为文件后缀名。每个源文件由：包声明语句（所属包）、import语句（导入依赖包）、其他（类型、变量、常量、函数等）

## 2.3 变量
一般形式：
var val T = expression

如果以var val T初始化val，则用零值初始化val。

零值初始化机制:
数值变量对应零值是0，布尔型是false，字符串类型对应的是“”空字符串，接口或引用类型（slice、map、chan和函数）对应的零值是nil。复合类型对应的零值是每一项都是零值。

Go语言的一个声明语句可以声明一组变量，即使不同类型。
Go语言的声明可以用类型，或类型推导。

### 简短变量声明
以val := expression声明变量，根据表达式来推导变量。
同事简短声明多个变量应该仅限于局部的可以提高代码可读性的地方使用。

:=是变量声明语句；=是变量赋值操作。
```
i, j := 0, 1
i, j = j, i
```

简短变量声明的左值，应该至少有一个新的变量，否则编译报错。

### 指针
声明一个指针
```
var val *T
val := &val0
p := new(T)
```

指针的零值都是nil。

Go语言中，返回函数中局部变量的地址是安全的。-_-
？？？如此使用？会不会使垃圾回收困难？比如层层返回一个局部指针，甚至长期驻留？

&操作取地址，相当于创建了新的别名。
指针的价值在于，我们可以不用名字，而是别名来访问变量。
Go语言的垃圾回收器需要知道变量的全部别名。

标准库flag包中的关键技术即是指针。
flag包用于处理-x/--x格式命令行参数，使用指针指向命令行标志参数变量做别名，用于程序处理。

new(T)创建一个匿名变量，并初始化为T的零值，返回*T。
new(T)同返回局部变量的地址行为相同。

struct{}和[0]int，类型的大小为0，可能地址相同，依赖于具体编译器，其自动垃圾回收器的行为也不同。

### 变量的声明周期
变量的声明周期从创建开始，直到其不再被引用。

函数的小括号里，可以另起一行缩进，但是要满足以(/,/)结束，不然编译器会在行尾自动插入分号导致编译错误。

Go语言的自动垃圾收集器通过每个变量是否可达，判断其是否可以被回收。
所以，一个循环迭代内部的局部变量的生命周期可能超出其作用域，同时，函数内局部变量可以在返回后依然存在（Go语言中称之为逃逸）。
编译器来选择在栈上还是在堆上分配局部变量的存储空间，且不取决与用var还是new声明变量。
逃逸的变量需要额外分配内存，对性能会产生细微的影响。

把局部短生命周期变量的指针保存到长生命周期的对象中，特别是全局变量时，会阻止对其的来及回收，进而影响性能。

## 2.4 赋值
Go语言支持 += ++等快捷代码，但++是语句，而不是表达式！！！

### 元组赋值：
允许同事更新多个变量的值。赋值前，先对右值求值，再统一赋给左值。很便利，且代码紧凑。

map查找、类型断言、通道接收，都有一个额外的布尔结果值表示操作是否成功。
```
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
```

可赋值性也即右值表达式/左值表达式，仅右值表达式可以放赋值语句右边，可以在==等的右边。

## 2.5 类型
type T basetype

不同的类型，即使它们的底层类型相同也是不兼容的（不能互相赋值、比较、混在一起运算）。
新命名的类型提供了一个方法T(x)(或(T)(x), 当T是指针类型时)，把x转为T类型，当且仅当两个类型的底层基础类型或指针类型相同时，才允许此转型操作。
一个浮点数转整数，会丢小数部分；把字符串转为[]byte类型slice，会拷贝出一个字符串的副本。
转换函数不会运行时失败，只会编译时失败。

命名类型较多地用于复杂struct类型书写简化。
命名类型还可以为其值定义新的行为，即关联到该类型的函数集合。
命名类型的String方法，会被fmt.Print系列优先使用

## 2.6 包和文件
包、文件是为支持模块化、封装、单独编译和代码重用。
一个包所在的目录路径的后缀是包的导入路径（$GOPATH/src后面的部分）。
每个包都对应一个独立的名字空间，不同包的同名变量需要显式使用包名以区分。不同名也不可以省略。
包内大写字母开头的变量是导出的，汉字和日文unicode编码相当于小写字母开头，需要特殊设置。
包级别的名字，在同包的其他源文件中是可以直接访问的，同所有代码在一个文件中。
惯例：包注释的第一句应该先是包的功能概要声明。如果一个包多个包注释，文档工具（go doc）会根据源文件先后顺序链接它们为一个包注释。
惯例：包注释很大，通常会放到一个独立的doc.go文件。

### 包导入
import语句中的字符串对应导入路径，由构建工具解释，默认的工具箱代表一个目录中的一个或多个Go源文件。
源文件中的包名，不要求唯一。
惯例：源文件中的包名，和import语句中的包的导入路径的最后一节目录名相同。
同时导入两个同名包，必须有一个同名包添加别名（原文，重命名）。
导入包，却没有使用，将导致一个编译错误，需要删除或注释掉。

- 工具goimports自动修改import语句。
- 工具gofmt自动格式化代码。
- go env // 查看golang环境变量
- GOROOT：golang的安装路径，安装时确定。
- GOPATH：golang工作路径；bin - 二进制文件路径; pkg - .a文件存放路径；src - go run、go install等命令路径
- GOBIN:go install的存放路径
- go get 下载
- go install会生成可执行文件放到bin目录；编译普通包，生成.a文件放到pkg目录。

### 包的初始化
同包变量先确定依赖顺序，再依次初始化。
构建工具先把.go文件根据文件排序，然后依次调用编译器编译。
包级变量，如果有初始化表达式，则用之。没有的可以用一个特殊的init()函数来简化初始化工作。
每个文件可以包含多个init函数。
init()不能本外部调用，在程序开始执行时，按照它们的声明顺序依次被自动调用。
初始化工作是自下而上的，main包最后被初始化。
init()函数初始化逻辑也可以包装成一个匿名函数处理：
```go
var t T = func() (t T) { t = t0 return }()
```

习题跳过了，未看。

## 2.7 作用域
作用域是一个编译时的属性,生命周期是运行时动态的概念，并不相同。
由花括弧包起来的多个语句成为语法块，其内声明的名字无法被外部语法块访问。
全部源代码同属一个全局语法块，包有包的语法块，for/if/switch后的隐式的语法块，switch/select分支语法块，显式书写花括弧里的语法块。
内置的类型、函数、常量是全局作用域的；导入的包的变量作用到该源文件；break/continue/(goto的label)都是函数级别作用域。
可以在不同作用域名字相同，但不可滥用。
编译器对一个名字引用由最内层到全局作用域查找其声明，内层的声明会屏蔽外层的同名声明，使其无法访问。
好的编程风格应该避免这种屏蔽。
声明的顺序不会影响作用域范围，先声明的可以引用其自身或其后的一个声明，完成相互嵌套或递归的类型或函数，但是变量常量不能引用自身。

惯例：Go语言习惯在if中处理错误直接返回，后续正常执行的代码可以不缩进。
注意：短变量声明语句，容易覆盖外层作用域声明的名字，易形成缺陷。
```go
var cwd string
func init() {
	var err error
	cwd, err = os.Getwd();	// 而不是 cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("XXXXXXXXXXXXXXXX %v, %s", err, cwd)
	}
}
```

# 第三章 基础数据类型
所有数据都是由比特组成，整数、浮点数、比特数组、内存地址等，复合在一起组成更丰富的类型，数据包、像素点、文档。
Go语言内置数据类型：基础类型（数字、字符串、布尔型）、复合类型（数组、结构体）、引用类型（指针、切片、字典、函数、通道）、接口类型。

## 3.1 整形
int8/int16/int32/int64;
uint8/uint16/uint32/uint64;
机器字长int/uint，取决于编译器和硬件平台。
Unicode字符rune类型与int32类型等价，用于表示一个Unicode码点，可以互换使用。
byte等价于uint8，更强调是一个原始的数据。
无符号整数类型uintptr，没有具体的bit大小，但足以容纳指针，仅用于底层编程，特别是Go语言与C语言函数库或操作系统接口交互的地方。
int与int32不同，需要显式类型转换操作。
有符号整数是2的补码形式表示，最高bit位表示符号位，其值域从-2^(n-1)到2^(n-1)-1。无符号整数，无符号位，表示非负数，从0到2^n-1。
建议：使用小括号明确优先级，提高可读性。
取模运算符%仅用于整数，且结果的符号和被取模数一致。
Go语言同样也会因计算而溢出，需要被处理。
整数、浮点数、布尔型、字符串等是可比较的，可排序，存在类型不可排序。？取决于？
按位异或^。&^是?
左移运算用零填充右边空位，无符号数右移运算也是用0填充左边空位，有符号数的右移运算用符号位填充左边空位。
位移运算最好用于无符数处理。
Go语言数组长度函数len()返回的是有符号int，可以逆序循环（无符号数导致panic）。
Go语言表达非负数量倾向于用有符号整数类型，无符号数仅用在位运算、bit集合、分析二进制文件格式、哈希操作、加密操作等。
八进制格式书写的整数字面值以0开始，十六进制的以0x/0X开头。八进制常用于POSIX操作系统上文件访问权限标志，十六进制更强调数字值的bit位模式。
格式化输出%d/%o/%x，指代不同进制。
字符使用%c参数打印，%q参数打印带单引号的字符。

## 3.2 浮点数
Go语言浮点数float32和float64，由IEEE754浮点数国际标准定义，被所有的CPU支持。
float32最大值math.MaxFloat32约3.4e38，最小值math.MinFloat32约1.4e-45；float64最大值math.MaxFloat64约1.8e308，最小值math.MinFloat64约4.9e-324。
通常应该优先使用float64，因为float32的累计计算误差很容易扩散。
%g参数采用更紧凑的表示形式打印；%e、%f参数更合适表格数据。
注意：浮点数的相等比较，不能直接比较。

## 3.3 复数
Go语言提供复数类型complex64/complex128（对应float32/float64），内置函数complex()构建复数，内建的real和imag函数返回复数的实部和虚部。
Go语言源文件中实数面值后面跟着i，即构成复数虚部。

## 3.4 布尔型
布尔值的短路行为：如果运算符左边的值已经可以判断整个布尔表达式的值，右边的值将不被求值。
&&比||优先级高。
布尔值不能隐式转换为数字值0或1可借if语句转换。

## 3.5 字符串
一个字符串是一个字节序列，可以包含任意数据。
文本字符串通常解释为采用UTF-8编码的Unicode码点(rune)序列。
内置len函数返回字符串的字节数目，而不是rune字符数目。
索引操作str[idx]需要满足：`0<= idx < len(str)`，否则引起panic异常1。
子字符串操作str[i:j]生成一个新字符串，即原始str的第i字节开始到j字节（不包含j），j小于i导致panic异常，0和len(str)可省略。
字符串不可修改，对字符串内部数据的赋值操作是被禁止的，导致编译错误（不变性）。

### 字符串面值
字符串面值可以用双引号包含字节序列，需要使用大量转义。
Go语言总用UTF8编码，其文本字符串，也以UTF8编码处理，Unicode码点也可以写到字符串面值中。
通过十六进制或八进制转义在字符串面值包含任意的字节，十六进制\xhh(两个数字，如\xFF、\x05)，八进制\ooo(三个数字，如最大\377)。

原生的字符串面值形式...，使用反引号代替双引号，没有转义操作，全部内容即字面意思，包含退格和换行，可跨越多行（无法书写的字符用八进制或十六进制转义或+"..."链接字符串常量）。
Go语言会删除原生字符串中的回车以保证所有平台上的值都是一样的。
原生字符串面值常用语编写正则表达式、HTML模版、JSON面值、命令行提示信息等需要扩展多行、很多反斜杠的地方。

### Unicode
ASCII使用7bit表示了128个字符（英文字母大小写、数字、各种标点符号、设置控制符）。
Unicode符号集，收集了世界上所有的符号系统，每个符号都分配一个唯一Unicode码，Go语言都有一个rune类型对应（rune英文意思是符文）。
Unicode第八版标准收集了12万字符，100多种语言。
Unicode通用int32表达，符文序列可以表示为一个int32序列（即UTF-32或USC-4），简单统一却浪费很多空间。

### UTF-8
UTF8将Unicode编码为变长字节的编码序列（Go语言之父也是Unicode之父之一）。
UTF8使用每个编码的第一个字节的高端bit表示共有多少字节。
UTF8中，ASCII部分字符仅使用1个字节，常用字符部分使用2或3个字节，首字节高端bit为0。
如果首字节高端bit是110，则共有2字节；如果是1110，则共有3字节；如果是11110，则共有4字节。
除首字节之外的字节，高端bit都以10开头。

变长字节编码，无法通过索引访问第n个字符。
但是编码紧凑，完全兼容ASCII编码，可以自动同步（向前回溯2个字节即可确定字符编码的开始字节位置）。
UTF8是个前缀编码，从左向右解码不会有任何歧义，也不需向前查看（GBK编码如果没有起点位置，会出现歧义）。
UTF8的每个编码的字节组是唯一的，不会互相影响。

UTF8编码顺序和Unicode码点顺序一致，可以直接排序UTF8编码序列，比较大小等。
UTF8编码中没有NUL(0)字节，可以兼容使用NUL做结尾的编程语言。

Go语言采用UTF8编码，提供了unicode/utf8包，用于rune字符序列的UTF8编解码功能。
Go语言支持Unicode码点转义字符，\uhhhh对应16bit的码点值，\Uhhhhhhhh对应32bit的码点值。
下面的字符串面值表示相同：
```go
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"
```

Go语言的range循环在处理字符串时，会隐式解码UTF8字符串。
如果遇到一个错误的UTF8编码字符，将生成一个特别的Unicode字符'\uFFFD'，印刷中是一个黑色六角或钻石形状，包含一个白色的问号。

UTF8字符串作为交换格式很方便，但程序内用rune序列处理更方便，rune序列的每个字符大小一致，支持数组索引且方便切割。
string转[]rune，将一个UTF8编码的字符串解码为Unicode字符序列；[]rune类型的Unicode字符slice或数组转string，则做UTF8编码。
整数转型为string的意思是，生成对应Unicode码点字符的UTF8字符串。

### 字符串和Byte切片
Go语言标准库涉及字符串处理常用四个包：bytes、strings、strconv、unicode。
strings提供字符串查询、替换、比较、截断、拆分、合并。
bytes提供strings类似功能，但针对[]byte类型。相比strings，bytes.Buffer的处理更高效。
strconv提供了布尔、整型、浮点、字符串、双引号转译的相互转换。
unicode提供了IsDigit、IsLetter、IsUpper、IsLower等功能，遵循Unicode标准，处理rune类型。

path和path/filepath包提供了关于文件路径名的一些函数操作（使用操作系统本身的路径规则）。


```go
s := "abc"
b := []byte(s)
s2 := string(b)
```
[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。
编译器做优化，以避免一些场景下分配和复制字符串数据，确保变量b被修改的情况下，原始的s字符串也不会改变。
string(b)操作则是构造了一个字符串拷贝，s2是只读的。

strings和bytes包有很多函数相似，区别是字符串类型参数被替换成了字节slice类型的参数。
bytes.Buffer类型用于字节slice缓存，可以当作I/O的输入和输出对象。

### 字符串和数字的转换

## 3.6 常量
常量表达式在编译期间计算。每种常量的潜在类型都是基础类型（布尔、string或数字）。
函数len、cap、real、imag、complex和unsafe.Sizeof返回的都是常数。
%T打印类型信息。

批量声明的常量，第一个常量的右值表达式不可省略，后续省略右值表达式的常量使用前面常量的初始化表达式（没有太实用价值，但可以带来iota常量生成器语法，即Go语言枚举类型）。

### iota常量生成器
```go
type Weekday int

const (
	Sunday Weekday = itoa
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
```
iota常量生成器用于生成一组以相似规则初始化的常量，不用声明每行都初始化。
第一个被置为0，其他的逐行加一。
如果是`1 << iota`，则依次是连续的2的幂。
iota不能产生10的幂，因为Go语言没有幂运算符。

### 无类型常量
Go语言的很多常量没有明确的基础类型，编译器为他们提供比基础类型更高精度的算数运算（256bits?）。
有六种未明确的常量类型：无类型布尔型、无类型整数、无类型字符、无类型浮点数、无类型复数、无类型字符串。
无类型常量，提供更高的运算精度，远超任何Go语言的整数类型表达。
无类型浮点数常量，可以直接用于任何需要浮点数的地方（隐式转换），不需显式转换。
常量面值、字符串面值常量都是无类型的常量。
无类型常量类型转基本类型。
无类型常量转接口，以明确接口对应的动态类型。
%T打印无类型常量。

# 第四章 复合数据类型
本章主讲四种类型：数组、slice、map、结构体，结构体如何编解码为JSON格式，并结合模版生成HTML页面。
数组、结构体都有固定的内存大小，slice、map是动态的数据结构，动态增长。

## 4.1 数组
```go
var a [3]int
var b [3]int = [3]int{1, 2, 3}
c := [...]int{1, 2, 4}
```
数组的长度必须是常量表达式，在编译阶段确定。
数组、slice、map和结构体的写法有一致性。
```go
type Currency int
const (
	USD Currency = iota
	EUR
	GBP
	RMB
)
symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
r := [...]int{99:-1}	// 长度100，初值为0，第100为-1
```
两个数组比较，仅所有元素相等，数组才相等。

函数内部接收参数的是一个复制的副本，不是原始变量，所以传递大的数组类型是低效的；且函数内的修改只影响副本，不影响原始变量（其他语言会隐式地把数组转为引用或指针对象传递）。
Go语言支持函数入参传递数组的指针，但较少使用数组做函数参数，一般使用slice替换数组。

## 4.2 Slice
slice书写为[]T，和数组语法很像，只是没有固定长度。
slice底层确实引用了一个数组对象。
slice三部分：指针、长度、容量。
slice指针指向其首元素地址（不一定是数组的首元素）。
slice长度即其元素的个数，小于等于容量。
slice容量是从开始位置到底层数据的结尾位置。
内置函数len和cap返回slice的长度和容量。
多个slice可以共享同一个数组，甚至该数组的相同部分。
切片操作str[i:j]，其中`0<=i<=j<=len(str)`；i省略默认为0；j省略默认为len(str);都省略则引用整个数组。
对字符串的切片操作和[]byte字节类型切片类似，切片操作具有常量时间复杂度。
Go语言中，函数入参传递数组常用省略i、j的切片。

函数入参slice创建了slice的一个别名，对其修改会影响原始变量。

slice不能用==比较是否元素相同，不过bytes.Equal可以比较字节型slice是否相等（其他类型的需要展开比较）。
slice是间接引用，==也不能用于判断其是否引用相同对象（浅相等测试），这种行为让人困惑？。
slice唯一合法的比较操作是与nil比较，nil值的slice没有底层数组，长度容量都是0。
Go语言中map等数据结构的key制作简单的浅拷贝，保证相等的key对应相同的元素。

slice判空，应该使用len(s) == 0，而不是s == nil。

内置函数make创建指定元素、长度、容量的匿名slice：
```go
make([]T, len)
make([]T, len, cap)
make([]T, cap)[:len]
```

### append函数
内置函数append用于向slice追加元素。
内置函数copy与赋值语句是一致，返回成功复制的元素的个数，等于两个参数中较小的长度。
append函数扩展slice的数组翻倍长度，使添加操作平均耗时是个常数时间。远超两倍呢？
append函数可以追加多个元素，甚至一个slice。

### slice内存技巧
以切片为入参，且返回切片的函数常用于过滤或合并相邻的元素。
slice可以用来模拟栈或队列（append做压入，索引访问栈顶，切片操作弹出栈顶）。
内置copy函数可以用于删除切片中间的元素`copy(slc[i:], slc[i+1]:)`，或`slc[i] = slc[len(slc)-1]`。

## 4.3 map
哈希表(map)是无序的key/value对的集合，key不重合，指定key，可在常数时间复杂度内检索、更新或删除对应的值。
Go语言中，map是一个哈希表的引用，书写为map[K]V。key和value的类型必须分别一致。key必须支持==比较运算。
惯例：不用浮点数做key。

创建map表达式：map[K]V{}。
内置make(map[K]V)生成一个匿名map。
map字面值{ key1: value1, key2: value2 }。

map使用下标语法访问元素。查找失败，返回value的零值。使用delete内置函数删除元素（delete(map1, key1)）
map中的value不是一个变量，仅是一个右值表达式，禁止对其做取址操作。（被编译器认为非法）？
如果map的value是指针类型，则可以做寻址操作。
如果map的value的类型是struct，则不能通过`map[key].member += 1`修改它，可以使用指针类型的value修改。

map的遍历顺序是随机的，需要显式排序，可以使用sort包的Strings函数对字符串slice排序。
map的零值是nil，大部分操作对map零值都是安全的，但是向nil值map插入元素导致panic异常。

不应使用value的零值判断元素是否存在，map的下标语法作为右值表达式产生两个值，第二个是布尔值，用于揭示元素是否存在。
map之间不能==比较运算，与nil判断是例外。判断map的每个元素是否相同，需要显式循环遍历（value比较不能直接==比较，需要判断是否存在）。
Go语言中map可以实现类似C++的set的数据结构。

处理不可比较的key类型，需要自定义key比较函数。


## 4.4 结构体
点操作符可用于指向结构体的指针访问其成员。
函数调用返回的是值，不能作为左值表达式，如果返回的是可取地址的变量（指针），则可以作为左值。
结构体类型不能包含自身，但可以包含自身类型的指针类型。
如果结构体的成员以大写字母开头，则该成员是导出的。

struct{}大小为0，不含信息，一般不使用。

### 结构体面值
Go语言常用成员名对应初始化来初始化结构体。
未导出的成员不能显式/隐式使用。
较大的结构体常使用指针方式传入和返回函数。
内置函数new？

### 结构体比较
如果结构体的每个成员都可以比较，则结构体也可以比较，并可用于map的key。

### 结构体嵌入和匿名成员
Go语言中可以只声明结构体的一个成员的数据类型，而不指定其名字，也即匿名成员。
匿名成员的数据类型必须是命名类型或命名类型指针。称这种类型嵌入了该结构体。
可以直接访问结构体匿名成员的属性，不需完整级联路径。
嵌套的结构体的初始化面值也是嵌套的`T{T0:T0{a:1, b:2}, c:3}`。
Printf函数中%v参数包含的#副词，表示用和Go语言类似的语法打印面值。
未导出的匿名成员导出的成员对于结构体也未导出的。

匿名成员只是点运算简短书写的语法糖。
嵌入一个没有子成员的匿名成员类型，往往是因为需要嵌入其方法集。
嵌入使Go语言有了对象组合成复杂对象的能力，是Go语言面向对象编程的核心。


## 4.5 JSON
Go语言对JSON、XML、ASN.1、ProtocalBuffers都有支持。
标准库encoding/json、encoding/xml、encoding/asn1，具有相似的API接口。
JSON类型（数字、布尔、字符串）、JSON数组["a0","a1"]、JSON对象{"k0":"v0"}。

Go语言中结构体slice等转为JSON的过程叫做编组（marshaling），可调用json.Marshaling完成，返回一个编码后的字节slice，没有空白缩进。
json.MarshalingIndent函数产生整齐缩进的输出，其后两个参数表示每一行的前缀和每层级的缩进。
编码时，默认使用结构体成员名做JSON对象（反射技术）。
只有导出的成员才被编码，这也是Go语言用大写字母开头导出的原因。

结构体成员Tag是和在编译阶段关联到该成员的元信息字符串，通常是一系列空格分隔的key:"value"键值对序列；用原生字符串面值形式书写（使用反引号包含）。
以json为key的值用于控制encoding/json等包的编解码行为，第一部分用于指定JSON对象的名字，omitempty选项，表示当该成员为空或零值时，不生成JSON对象。

unmarshaling，json/unmarshaling，解码JSON数据。
url.QueryEscape对url特殊字符进行转译操作。


## 4.6 文本和HTML模版
text/template和html/template等包提供更复杂的打印格式，提供一个将变量填充到文本或HTML格式的模版的机制。


# 第五章 函数
函数机制用于程序分解为一个个单元。递归函数、匿名函数、错误处理等。

## 5.1 函数声明
函数名、形式参数列表、返回值列表、函数体`·func name(param-list) (return-list) { body }`。
```go
func f(i, j int, s, t string) (z int) { z = i+j; return }
func f(i int, j int, s string, t string) int { return i+j } // 等价的声明
func f(i int, _ int) int { return i }
func f(int, int) int { return 0 }
```
上述四种声明的func的Printf参数%T都是`func(int, int) int`。

函数的类型被称为函数的标识符，如果两个函数形参列表和回值列表的边浪类型一一对应，则这两个函数称为有相同的类型和标识符。
Go语言函数没有默认参数值。
函数调用者不关系函数声明的形参名，仅需依序提供实参列表。
Go语言实参和形参是值拷贝传递，即使是指针等数据结构，不过指针提供一种间接访问。

没有函数体，仅声明了标识符的函数一般不是Go实现的。

## 5.2 递归
大部分编程语言使用固定大小的函数调用栈，从64KB到2MB不等，限制了递归的深度，程序中需要避免栈溢出及安全性问题。
Go语言使用可变栈，栈的大小按需增加，使用递归时不必考虑溢出和安全问题。

## 5.3 多返回值
可以将一个返回多参数的函数作为一个接受多参数函数的参数，很利于调试，但实际上很少这样做。?
Go语言惯例：函数的最后一个bool类型的返回值标识函数是否运行成功，error类型的返回值代表函数的错误信息，不必有命名。
bare return：一个函数所有的返回值都有显式变量名，则该函数的return语句可以省略操作数。
bare return可以减少代码重复，但可读性下降，不宜过度使用。

## 5.4 错误
Go语言中，部分函数总能成功，部分函数输入满足条件也能成功，大部分函数不能确保成功。
Go语言的错误处理中，程序运行失败被认为是预期的结果之一。
惯例：一些函数的最后一个返回值通常用于传递错误信息，可以是个布尔值或error类型。
error类型是接口类型，可能是nil，表示函数运行成功；或non-nil，表示失败，此时其他返回值是未定义的，应当被忽略。
error的Error函数或输出函数可获得字符串类型的错误信息。
error错误与异常不同，异常是未预期的错误，而不是已经被避免的错误。

### 错误处理策略
1.传播错误。
2.重试失败的操作，限制间隔和次数。（偶然性的、不可预知的问题导致的？不可靠的网络。）
3.输出错误信息并退出。（只应在main中执行）
4.输出错误信息，继续。
5.直接忽略，处理。（某些系统自会处理的事情，或自恢复的）

惯例：错误信息以链式组合在一起，避免大写和换行符，便于grep处理。错误信息应该详尽且表达一致。

log.Fatalf()导致程序退出。
log包的SetPrefix和SetFlags函数。

Go语言推荐风格：失败的逻辑代码放在成功的前面，成功的代码直接放在函数体中。

### 文件结尾错误EOF
io包的任何由文件结束引起的读取失败都返回同一个错误io.EOF。
error错误可以==比较。

## 5.5 函数值
Go语言中，函数被归于第一类值first-class values：拥有类型，可被赋值给变量，传递给函数，从函数返回。其调用与函数调用相同。
函数类型的零值是nil，对其调用引起panic错误，函数值可与nil比较，不可互相比较，不可做map的key。

## 5.6 匿名函数
函数字面量，可在表达式中表示一个函数值。与函数声明类似，但没有函数名，称为匿名函数。
匿名函数可以访问其词法环境，即命名函数内嵌的匿名函数可以引用函数的变量。
Go语言函数值不仅是代码块，还记录了状态，匿名函数可以访问和更新其上层函数的局部变量，或者说匿名函数里保存有该局部变量的引用。
Go语言使用闭包技术实现函数值，函数值即闭包。
所以，变量的生命周期不由其作用域决定。

### 警告：捕获迭代变量
因为for的循环变量的作用域单独一层，循环体内是一层，内层的匿名函数访问了上层的循环变量，使该循环变量成为匿名函数的记录。所以多次匿名函数引用for的循环变量，可能导致匿名函数最终被调用时不符合预期，需要先保存在循环内部的变量中，再被匿名函数访问。
该问题同样存在于range循环、go语句、defer语句等。

## 5.7 可变参数
函数的参数列表的最后一个参数的类型之前加上省略符号，表示该函数可接受多个该类型参数，该参数称为可变参数。
可变参数可以当作切片处理，但并不是切片。是一种隐式类型？
将切片传递给可变参数，需要在其后加上省略符号。
被interface{}修饰的参数表示接收任意类型。

## 5.8 Deferred 函数
defer修饰的语句会在其所在的函数执行完毕时（包括return、panic异常等）执行。
defer常用于处理成对的操作，打开关闭、连接断开、加锁释放等。
一个函数中多个defer语句的执行顺序与其声明顺序相反。

defer机制加上匿名函数用于记录何时进入和退出函数（defer修饰一个函数返回的匿名函数的执行语句，切记不能少了最后的函数调用运算符()。
defer机制加上匿名函数可以将函数体后部分的语句前置。

当defer用于for循环中释放资源，最好将for循环中的打开资源和释放资源封装到一个函数中。

defer延后执行的语句最好不要用于覆盖函数体中语句的执行的结果。

## 5.9 Panic异常
数组访问越界、空指针引用等，这类运行时panic异常，会中断运行，并立即执行goroutine中被延迟defer的函数，随后程序崩溃并输出日志信息。
panic日志信息包括panic value和函数调用的堆栈跟踪信息。
panic内置函数也会引发panic异常，接收任何类型参数。类似于Clang中的assert断言。
惯例：panic函数适用于某些理论上可能发生，实际不应该发生的逻辑路径上。
除非需要提供跟多的错误信息，否则不必使用panic函数。
panic一般用于程序内部逻辑不一致（不自洽），并引起程序崩溃的严重后果。
一般应该使用错误机制处理大部分的预料的错误，而不是panic。预料之外的错误应该使用panic函数？
Go语言倾向契约式编程，程序内部的调用者应该遵守被调用者的契约或预期，否则触发panic异常。
惯例：Go语言函数名的Must前缀标识该函数不接收不合法的输入。兼容了契约式编程和防御式编程。

panic函数加上defer机制可以完成优雅退出，defer语句在释放堆栈信息之前执行。

runtime.Stack函数获取堆栈信息。

## 5.10 Recover捕获异常
一般不该对panic异常做处理。
web服务器崩溃前应该把所有连接关闭，避免客户端一直等待；开发阶段中服务器端崩溃前把异常信息反馈给客户端，便于调试。
如果defer函数中调用了内置函数recover()，且其所在函数执行出了panic异常，recover使执行从panic中恢复，并返回panic value，最终发生panic异常的函数不再运行，但可正常返回。

把所有panic异常都恢复的做法会导致漏洞被忽略，并不可取，且不能包级变量是否与预期一致。
一个包里的逻辑不应该去恢复其他包引起的panic，也不应该恢复外部传入的函数参数的执行引发的panic（无法保证安全性）。

web服务的业务处理函数导致的panic时，会调用recover，输出堆栈信息，恢复执行，很便捷但也容易出问题。

惯例：recover时对panic value检查，如果是特殊类型，则作为error处理，并恢复执行，否则异常崩溃。

有些情况，无法恢复，如内存不足，Go程序必须终止运行。

# 第六章 方法
Go语言没有对象？，但是有方法，有OOP编程中的关键：封装和组合。

## 6.1 方法声明
在函数声明中的函数名之前放上一个带有类型的变量（用小括号括起来），即是一个方法声明，称该函数是该类型的一个方法，称该变量为方法的接收器（receiver），OOP中调用该方法称为向一个对象发送消息。
此书建议使用类型首字母小写作为接收器名，具备方法间传递的一致性和简洁性。
调用无接收器的函数称为包级别的函数调用。
调用有接收器的函数称为接收器的类型下声明的方法的调用，该调用表达式称为选择器（选择该类型的某个函数或该struct类型的某个字段来调用）。
struct类型的方法和字段不能重名，也不能和其字段的方法重名。
Go语言中，可以为一些简单的数值、字符串、slice、map（只要不是一个指针？或者interface）来定义方法，附加行为。
方法比函数的好处：名字更简短；包外调用不用包名。

## 6.2 基于指针对象的方法
当需要修改类型实例的值时，需要用指针；当这个类型比较大时，也可以用指针而不是对象来声明方法。
惯例：Go语言中，如果一个类型有方法用一个指针作为接收器，则所有的方法都必须用指针做接收器。但可以不这样？
接收器只能是类型和指向他们的指针。不能是二级指针？
如果一个类型本身是一个指针，是不能作为接收器的。
调用指针类型方法，仅需要书写变量即可，和类型方法一样调用。
Go语言会隐式调用&取址和*取值？
无法获取临时变量的内存地址，也无法用临时变量调用指针方法。右值表达式无法获得地址？

如果一个类型的所有方法都使用类型自己做接收器，则拷贝类型是安全性的；如果一个类型的所有方法使用指针做接收器，需要避免拷贝，可能会破坏其不变性。

### Nil也是一个合法的接收器类型
值为nil的对象也可以调用方法。
惯例：如果允许nil调用方法，在方法的前面的注释中指出nil值代表的意义。

## 6.3 通过嵌入结构体来扩展类型
Go语言结构体实例可以调用嵌入它的成员的方法（省略了成员的书写），来做到类型扩展。
结构体并不是嵌入其成员的继承类（不能用它隐式转成其成员类型实例来使用），两者是"has a"关系。
内嵌把一个类型的方法引入另一个类型，编译器会生成额外的包装方法来委托内嵌成员类型已经声明的方法。
类型中内嵌的匿名成员，且是命名类型指针的，字段和方法是间接地引入该类型（也即需要通过该指针对象访问，如此，可以共享通用结构并动态地修改）。

当编译器解析一个选择器的方法时，先找其类型定义的方法，再找内嵌字段引入的方法，再找内嵌字段的内嵌字段引入的方法，依次递归向下。
如果选择器有二义性的话（同一级里有同名方法），编译器会报错。不同级呢？

对于字段特别多的复杂类型，可以把字段组合起来成小类型，结合方法设计，形成嵌入结构。
方法可以定义在在类型或指向类型的指针或类型嵌套的成员（尤其匿名成员）上。

一个小trick：关联性很强的包级变量可以用一个变量封装，这个变量是一个嵌套了这些包级变量的匿名类型的实例。这样带来更好的可读性。

## 6.4 方法值和方法表达式
常用instance.fun(param)调用方法，可以分为两步：
```go
method = instance.fun
method(param)
```
其中，instance.fun称为选择器，返回一个方法值，将方法绑定到特定接收器变量的函数类型变量。这样不用指定接收器，只需传入参数即可调用方法。
`func() { instance.fun() }`可以缩写为`instance.fun`。
方法相比函数，必须指定选择器以决定接收器。

方法表达式T.f或(*T).f，返回一个函数值，该函数值把第一个参数当作接收器（不用书写选择器，而是相等价）。
方法表达式常用于根据变量来决定调用同一类型的不同具体函数时使用。

## 6.5 示例：Bit数组
Go语言中，常用map[T]bool表达集合，很灵活，但用bit数组更好，在数据流分析领域bit数组表现更加理想。

## 6.6 封装
一个对象的变量或方法对调用方不可见，称为封装/信息隐藏。
Go语言只有通过首字母大小写控制可见性，适用于包级成员、struct成员，最小封装单元是包（package）。
封装三优点：1.调用方不能直接修改隐藏的变量值，包开发者可以用来做到到包的不变性；2.调用方不用关心函数（包括方法）实现细节；3.？

惯例：Go语言省略掉getter函数的Get前缀，setter不省略Set前缀（这种偏好也使用与Find、Fetch、Lookup等）。
Go不禁用包或struct的字段导出，但为了API兼容，请一开始设计时，深思熟虑。

封装是必要的，但并不总是理想的，有些场景需要暴露包内部字段。

# 第七章
Go语言接口类型是对其他类型行为的抽象和概括!接口不与特定实现细节绑定在一起。
接口类型让函数更加灵活，更具适应能力。

Go语言接口概念的独特之处在于满足隐式实现，也即不需绑定具体类型到接口类型上，可以创建一些新接口类型且不用修改具体类型的定义。
接口类型的隐式实现，尤其适用于来自第三方开发的包中设计的具体类型。
接口只需要简单拥有一些方法就可以了？

个人理解接口类型也很像泛型？

## 7.1 接口约定
一段代码中，一个具体类型可以使用另一个满足相同接口的类型来进行替换，称作这段代码里这个类型具有可替换性（LSP里氏替换）。
Go语言中io包的Writer就是接口类型，fmt.Fprintf接收一个io.Writer类型的参数。
fmt包中的Stringer都是接口类型，它有一个返回string的String()方法，用于支持传统符号打印。

## 7.2 接口类型
接口类型表述的是一系列方法的集合，实现了这些方法的具体类型是该接口类型的实例。
惯例：Go语言中一些基础接口类型是单方法接口类型，方法名称使用动词，类型名称使用对应的名词，如read/reader。
接口类型可以通过组合已有接口来定义，与内嵌相似，成为接口内嵌（当然也可以使用方法，是等价的）。

## 7.3 实现接口的条件
如果一个类型实现了一个接口的所有方法，则这个类型就实现了这个接口。
开发者把一个或多个具体类型描述成一个特定接口类型的过程就是抽象。
可以把实现了接口的具体类型（或另一个接口类型）的右值表达式赋值给接口类型的变量实例。
注意：类型的指针上定义的方法不是类型上定义的方法，在赋值给接口类型的变量时是有区别的？

godoc -anlysis=typetool 展示每个类型的方法和具体类型和接口之间的关系。

接口类型用于封装和隐藏具体类型的其他方法和值，只暴露出其定义的方法。

接口类型interface{}称为空接口类型，在Go语言有特殊含义，该接口类型对实现它的类型没有要求，可以把任何值赋值给它。
空接口类型没有成员或方法，不能直接操作空接口类型的变量。

是否实现接口仅依赖于判断两个类的方法，没必要书写两个类的关系，或文档、或断言。编译时会断言是否实现。

## 7.4 flag.Value接口
Go语言标准中的flag.Value接口类型用于帮助命令行标记定义新的符号。

